#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RuntimeMeshComponent

#include "Basic.hpp"

#include "RuntimeMeshComponent_classes.hpp"
#include "RuntimeMeshComponent_parameters.hpp"


namespace SDK
{

// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.AddIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::AddIndex(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 NewIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "AddIndex");

	Params::RuntimeBlueprintMeshBuilder_AddIndex Parms{};

	Parms.NewIndex = NewIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.AddTriangle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index1                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index2                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::AddTriangle(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index0, int32 Index1, int32 Index2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "AddTriangle");

	Params::RuntimeBlueprintMeshBuilder_AddTriangle Parms{};

	Parms.Index0 = Index0;
	Parms.Index1 = Index1;
	Parms.Index2 = Index2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.AddVertex
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRuntimeMeshTangent&       Tangent                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector2D&                 UV0                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::AddVertex(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, const struct FVector& InPosition, const struct FVector& Normal, const struct FRuntimeMeshTangent& Tangent, const struct FVector2D& UV0, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "AddVertex");

	Params::RuntimeBlueprintMeshBuilder_AddVertex Parms{};

	Parms.InPosition = std::move(InPosition);
	Parms.Normal = std::move(Normal);
	Parms.Tangent = std::move(Tangent);
	Parms.UV0 = std::move(UV0);
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.EmptyIndices
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Slack                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeBlueprintMeshBuilder::EmptyIndices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Slack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "EmptyIndices");

	Params::RuntimeBlueprintMeshBuilder_EmptyIndices Parms{};

	Parms.Slack = Slack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.EmptyVertices
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Slack                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeBlueprintMeshBuilder::EmptyVertices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Slack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "EmptyVertices");

	Params::RuntimeBlueprintMeshBuilder_EmptyVertices Parms{};

	Parms.Slack = Slack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.GetColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor URuntimeBlueprintMeshBuilder::GetColor(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "GetColor");

	Params::RuntimeBlueprintMeshBuilder_GetColor Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.GetIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::GetIndex(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "GetIndex");

	Params::RuntimeBlueprintMeshBuilder_GetIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.GetNormal
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 URuntimeBlueprintMeshBuilder::GetNormal(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "GetNormal");

	Params::RuntimeBlueprintMeshBuilder_GetNormal Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.GetPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URuntimeBlueprintMeshBuilder::GetPosition(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "GetPosition");

	Params::RuntimeBlueprintMeshBuilder_GetPosition Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.GetTangent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URuntimeBlueprintMeshBuilder::GetTangent(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "GetTangent");

	Params::RuntimeBlueprintMeshBuilder_GetTangent Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.GetUV
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D URuntimeBlueprintMeshBuilder::GetUV(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, int32 Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "GetUV");

	Params::RuntimeBlueprintMeshBuilder_GetUV Parms{};

	Parms.Index_0 = Index_0;
	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.IsReadonly
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeBlueprintMeshBuilder::IsReadonly(class URuntimeBlueprintMeshBuilder** OutMeshBuilder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "IsReadonly");

	Params::RuntimeBlueprintMeshBuilder_IsReadonly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.IsUsing32BitIndices
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeBlueprintMeshBuilder::IsUsing32BitIndices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "IsUsing32BitIndices");

	Params::RuntimeBlueprintMeshBuilder_IsUsing32BitIndices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.IsUsingHighPrecisionTangents
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeBlueprintMeshBuilder::IsUsingHighPrecisionTangents(class URuntimeBlueprintMeshBuilder** OutMeshBuilder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "IsUsingHighPrecisionTangents");

	Params::RuntimeBlueprintMeshBuilder_IsUsingHighPrecisionTangents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.IsUsingHighPrecisionUVs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeBlueprintMeshBuilder::IsUsingHighPrecisionUVs(class URuntimeBlueprintMeshBuilder** OutMeshBuilder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "IsUsingHighPrecisionUVs");

	Params::RuntimeBlueprintMeshBuilder_IsUsingHighPrecisionUVs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.NumIndices
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::NumIndices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "NumIndices");

	Params::RuntimeBlueprintMeshBuilder_NumIndices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.NumUVChannels
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::NumUVChannels(class URuntimeBlueprintMeshBuilder** OutMeshBuilder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "NumUVChannels");

	Params::RuntimeBlueprintMeshBuilder_NumUVChannels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.NumVertices
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::NumVertices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "NumVertices");

	Params::RuntimeBlueprintMeshBuilder_NumVertices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.SetColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::SetColor(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "SetColor");

	Params::RuntimeBlueprintMeshBuilder_SetColor Parms{};

	Parms.Index_0 = Index_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.SetIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeBlueprintMeshBuilder::SetIndex(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "SetIndex");

	Params::RuntimeBlueprintMeshBuilder_SetIndex Parms{};

	Parms.Index_0 = Index_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.SetNormal
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector4&                  Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::SetNormal(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector4& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "SetNormal");

	Params::RuntimeBlueprintMeshBuilder_SetNormal Parms{};

	Parms.Index_0 = Index_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.SetNormalTangent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRuntimeMeshTangent&       Tangent                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::SetNormalTangent(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector& Normal, const struct FRuntimeMeshTangent& Tangent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "SetNormalTangent");

	Params::RuntimeBlueprintMeshBuilder_SetNormalTangent Parms{};

	Parms.Index_0 = Index_0;
	Parms.Normal = std::move(Normal);
	Parms.Tangent = std::move(Tangent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.SetNumIndices
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeBlueprintMeshBuilder::SetNumIndices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 NewNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "SetNumIndices");

	Params::RuntimeBlueprintMeshBuilder_SetNumIndices Parms{};

	Parms.NewNum = NewNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.SetNumVertices
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeBlueprintMeshBuilder::SetNumVertices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 NewNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "SetNumVertices");

	Params::RuntimeBlueprintMeshBuilder_SetNumVertices Parms{};

	Parms.NewNum = NewNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.SetPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::SetPosition(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "SetPosition");

	Params::RuntimeBlueprintMeshBuilder_SetPosition Parms{};

	Parms.Index_0 = Index_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.SetTangent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRuntimeMeshTangent&       Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::SetTangent(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FRuntimeMeshTangent& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "SetTangent");

	Params::RuntimeBlueprintMeshBuilder_SetTangent Parms{};

	Parms.Index_0 = Index_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.SetTangents
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TangentX                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TangentY                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TangentZ                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::SetTangents(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector& TangentX, const struct FVector& TangentY, const struct FVector& TangentZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "SetTangents");

	Params::RuntimeBlueprintMeshBuilder_SetTangents Parms{};

	Parms.Index_0 = Index_0;
	Parms.TangentX = std::move(TangentX);
	Parms.TangentY = std::move(TangentY);
	Parms.TangentZ = std::move(TangentZ);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.SetUV
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::SetUV(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector2D& Value, int32 Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "SetUV");

	Params::RuntimeBlueprintMeshBuilder_SetUV Parms{};

	Parms.Index_0 = Index_0;
	Parms.Value = std::move(Value);
	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeBlueprintMeshBuilder.SetVertex
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeBlueprintMeshBuilder**    OutMeshBuilder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRuntimeMeshTangent&       Tangent                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector2D&                 UV0                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeBlueprintMeshBuilder::SetVertex(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector& InPosition, const struct FVector& Normal, const struct FRuntimeMeshTangent& Tangent, const struct FVector2D& UV0, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeBlueprintMeshBuilder", "SetVertex");

	Params::RuntimeBlueprintMeshBuilder_SetVertex Parms{};

	Parms.Index_0 = Index_0;
	Parms.InPosition = std::move(InPosition);
	Parms.Normal = std::move(Normal);
	Parms.Tangent = std::move(Tangent);
	Parms.UV0 = std::move(UV0);
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshBuilder != nullptr)
		*OutMeshBuilder = Parms.OutMeshBuilder;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.AddCollisionBox
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRuntimeMeshCollisionBox&  NewBox                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMesh::AddCollisionBox(const struct FRuntimeMeshCollisionBox& NewBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "AddCollisionBox");

	Params::RuntimeMesh_AddCollisionBox Parms{};

	Parms.NewBox = std::move(NewBox);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.AddCollisionCapsule
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRuntimeMeshCollisionCapsule&NewCapsule                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMesh::AddCollisionCapsule(const struct FRuntimeMeshCollisionCapsule& NewCapsule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "AddCollisionCapsule");

	Params::RuntimeMesh_AddCollisionCapsule Parms{};

	Parms.NewCapsule = std::move(NewCapsule);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.AddCollisionSphere
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRuntimeMeshCollisionSphere&NewSphere                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMesh::AddCollisionSphere(const struct FRuntimeMeshCollisionSphere& NewSphere)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "AddCollisionSphere");

	Params::RuntimeMesh_AddCollisionSphere Parms{};

	Parms.NewSphere = std::move(NewSphere);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.AddConvexCollisionSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           ConvexVerts                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMesh::AddConvexCollisionSection(const TArray<struct FVector>& ConvexVerts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "AddConvexCollisionSection");

	Params::RuntimeMesh_AddConvexCollisionSection Parms{};

	Parms.ConvexVerts = std::move(ConvexVerts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.ClearAllConvexCollisionSections
// (Final, Native, Public, BlueprintCallable)

void URuntimeMesh::ClearAllConvexCollisionSections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "ClearAllConvexCollisionSections");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.ClearAllMeshCollisionSections
// (Final, Native, Public, BlueprintCallable)

void URuntimeMesh::ClearAllMeshCollisionSections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "ClearAllMeshCollisionSections");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.ClearAllMeshSections
// (Final, Native, Public, BlueprintCallable)

void URuntimeMesh::ClearAllMeshSections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "ClearAllMeshSections");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.ClearCollisionBoxes
// (Final, Native, Public, BlueprintCallable)

void URuntimeMesh::ClearCollisionBoxes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "ClearCollisionBoxes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.ClearCollisionCapsules
// (Final, Native, Public, BlueprintCallable)

void URuntimeMesh::ClearCollisionCapsules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "ClearCollisionCapsules");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.ClearCollisionSpheres
// (Final, Native, Public, BlueprintCallable)

void URuntimeMesh::ClearCollisionSpheres()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "ClearCollisionSpheres");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.ClearConvexCollisionSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ConvexSectionIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::ClearConvexCollisionSection(int32 ConvexSectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "ClearConvexCollisionSection");

	Params::RuntimeMesh_ClearConvexCollisionSection Parms{};

	Parms.ConvexSectionIndex = ConvexSectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.ClearMeshCollisionSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CollisionSectionIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::ClearMeshCollisionSection(int32 CollisionSectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "ClearMeshCollisionSection");

	Params::RuntimeMesh_ClearMeshCollisionSection Parms{};

	Parms.CollisionSectionIndex = CollisionSectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.ClearMeshSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::ClearMeshSection(int32 SectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "ClearMeshSection");

	Params::RuntimeMesh_ClearMeshSection Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.CookCollisionNow
// (Final, Native, Public, BlueprintCallable)

void URuntimeMesh::CookCollisionNow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "CookCollisionNow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.CreateMeshSection_Blueprint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Normals                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRuntimeMeshTangent>&Tangents                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UV0                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UV1                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FLinearColor>&      Colors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCalculateNormalTangent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldCreateHardTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGenerateTessellationTriangles                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUpdateFrequency                        UpdateFrequency                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionUVs                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::CreateMeshSection_Blueprint(int32 SectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, const TArray<struct FVector>& Normals, const TArray<struct FRuntimeMeshTangent>& Tangents, const TArray<struct FVector2D>& UV0, const TArray<struct FVector2D>& UV1, const TArray<struct FLinearColor>& Colors, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "CreateMeshSection_Blueprint");

	Params::RuntimeMesh_CreateMeshSection_Blueprint Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.Normals = std::move(Normals);
	Parms.Tangents = std::move(Tangents);
	Parms.UV0 = std::move(UV0);
	Parms.UV1 = std::move(UV1);
	Parms.Colors = std::move(Colors);
	Parms.bCreateCollision = bCreateCollision;
	Parms.bCalculateNormalTangent = bCalculateNormalTangent;
	Parms.bShouldCreateHardTangents = bShouldCreateHardTangents;
	Parms.bGenerateTessellationTriangles = bGenerateTessellationTriangles;
	Parms.UpdateFrequency = UpdateFrequency;
	Parms.bUseHighPrecisionTangents = bUseHighPrecisionTangents;
	Parms.bUseHighPrecisionUVs = bUseHighPrecisionUVs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.CreateMeshSectionFromBuilder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeBlueprintMeshBuilder*     MeshData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUpdateFrequency                        UpdateFrequency                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::CreateMeshSectionFromBuilder(int32 SectionID, class URuntimeBlueprintMeshBuilder* MeshData, bool bCreateCollision, EUpdateFrequency UpdateFrequency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "CreateMeshSectionFromBuilder");

	Params::RuntimeMesh_CreateMeshSectionFromBuilder Parms{};

	Parms.SectionID = SectionID;
	Parms.MeshData = MeshData;
	Parms.bCreateCollision = bCreateCollision;
	Parms.UpdateFrequency = UpdateFrequency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.CreateMeshSectionPacked_Blueprint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRuntimeMeshBlueprintVertexSimple>&Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCalculateNormalTangent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldCreateHardTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGenerateTessellationTriangles                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUpdateFrequency                        UpdateFrequency                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionUVs                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::CreateMeshSectionPacked_Blueprint(int32 SectionIndex, const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "CreateMeshSectionPacked_Blueprint");

	Params::RuntimeMesh_CreateMeshSectionPacked_Blueprint Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.bCreateCollision = bCreateCollision;
	Parms.bCalculateNormalTangent = bCalculateNormalTangent;
	Parms.bShouldCreateHardTangents = bShouldCreateHardTangents;
	Parms.bGenerateTessellationTriangles = bGenerateTessellationTriangles;
	Parms.UpdateFrequency = UpdateFrequency;
	Parms.bUseHighPrecisionTangents = bUseHighPrecisionTangents;
	Parms.bUseHighPrecisionUVs = bUseHighPrecisionUVs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.GetSectionBoundingBox
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox URuntimeMesh::GetSectionBoundingBox(int32 SectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "GetSectionBoundingBox");

	Params::RuntimeMesh_GetSectionBoundingBox Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.GetSectionMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* URuntimeMesh::GetSectionMaterial(int32 SectionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "GetSectionMaterial");

	Params::RuntimeMesh_GetSectionMaterial Parms{};

	Parms.SectionID = SectionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.IsCollisionUsingAsyncCooking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMesh::IsCollisionUsingAsyncCooking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "IsCollisionUsingAsyncCooking");

	Params::RuntimeMesh_IsCollisionUsingAsyncCooking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.IsCollisionUsingComplexAsSimple
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMesh::IsCollisionUsingComplexAsSimple()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "IsCollisionUsingComplexAsSimple");

	Params::RuntimeMesh_IsCollisionUsingComplexAsSimple Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.IsMeshSectionCollisionEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMesh::IsMeshSectionCollisionEnabled(int32 SectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "IsMeshSectionCollisionEnabled");

	Params::RuntimeMesh_IsMeshSectionCollisionEnabled Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.RemoveCollisionBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::RemoveCollisionBox(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "RemoveCollisionBox");

	Params::RuntimeMesh_RemoveCollisionBox Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.RemoveCollisionCapsule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::RemoveCollisionCapsule(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "RemoveCollisionCapsule");

	Params::RuntimeMesh_RemoveCollisionCapsule Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.RemoveCollisionSphere
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::RemoveCollisionSphere(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "RemoveCollisionSphere");

	Params::RuntimeMesh_RemoveCollisionSphere Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetCollisionBoxes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FRuntimeMeshCollisionBox>&NewBoxes                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetCollisionBoxes(const TArray<struct FRuntimeMeshCollisionBox>& NewBoxes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetCollisionBoxes");

	Params::RuntimeMesh_SetCollisionBoxes Parms{};

	Parms.NewBoxes = std::move(NewBoxes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetCollisionCapsules
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FRuntimeMeshCollisionCapsule>&NewCapsules                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetCollisionCapsules(const TArray<struct FRuntimeMeshCollisionCapsule>& NewCapsules)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetCollisionCapsules");

	Params::RuntimeMesh_SetCollisionCapsules Parms{};

	Parms.NewCapsules = std::move(NewCapsules);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetCollisionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERuntimeMeshCollisionCookingMode        NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetCollisionMode(ERuntimeMeshCollisionCookingMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetCollisionMode");

	Params::RuntimeMesh_SetCollisionMode Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetCollisionSpheres
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FRuntimeMeshCollisionSphere>&NewSpheres                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetCollisionSpheres(const TArray<struct FRuntimeMeshCollisionSphere>& NewSpheres)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetCollisionSpheres");

	Params::RuntimeMesh_SetCollisionSpheres Parms{};

	Parms.NewSpheres = std::move(NewSpheres);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetCollisionUseAsyncCooking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetCollisionUseAsyncCooking(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetCollisionUseAsyncCooking");

	Params::RuntimeMesh_SetCollisionUseAsyncCooking Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetCollisionUseComplexAsSimple
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetCollisionUseComplexAsSimple(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetCollisionUseComplexAsSimple");

	Params::RuntimeMesh_SetCollisionUseComplexAsSimple Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetConvexCollisionSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ConvexSectionIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           ConvexVerts                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetConvexCollisionSection(int32 ConvexSectionIndex, const TArray<struct FVector>& ConvexVerts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetConvexCollisionSection");

	Params::RuntimeMesh_SetConvexCollisionSection Parms{};

	Parms.ConvexSectionIndex = ConvexSectionIndex;
	Parms.ConvexVerts = std::move(ConvexVerts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetMeshCollisionSection
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   CollisionSectionIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetMeshCollisionSection(int32 CollisionSectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetMeshCollisionSection");

	Params::RuntimeMesh_SetMeshCollisionSection Parms{};

	Parms.CollisionSectionIndex = CollisionSectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetMeshSectionCastsShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewCastsShadow                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetMeshSectionCastsShadow(int32 SectionIndex, bool bNewCastsShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetMeshSectionCastsShadow");

	Params::RuntimeMesh_SetMeshSectionCastsShadow Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.bNewCastsShadow = bNewCastsShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetMeshSectionCollisionEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewCollisionEnabled                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetMeshSectionCollisionEnabled(int32 SectionIndex, bool bNewCollisionEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetMeshSectionCollisionEnabled");

	Params::RuntimeMesh_SetMeshSectionCollisionEnabled Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.bNewCollisionEnabled = bNewCollisionEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetMeshSectionVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetMeshSectionVisible(int32 SectionIndex, bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetMeshSectionVisible");

	Params::RuntimeMesh_SetMeshSectionVisible Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.bNewVisibility = bNewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetSectionMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetSectionMaterial(int32 SectionID, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetSectionMaterial");

	Params::RuntimeMesh_SetSectionMaterial Parms{};

	Parms.SectionID = SectionID;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetSectionTessellationTriangles
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SectionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetSectionTessellationTriangles(int32 SectionID, const TArray<int32>& Triangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetSectionTessellationTriangles");

	Params::RuntimeMesh_SetSectionTessellationTriangles Parms{};

	Parms.SectionID = SectionID;
	Parms.Triangles = std::move(Triangles);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.SetShouldSerializeMeshData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldSerialize                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::SetShouldSerializeMeshData(bool bShouldSerialize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "SetShouldSerializeMeshData");

	Params::RuntimeMesh_SetShouldSerializeMeshData Parms{};

	Parms.bShouldSerialize = bShouldSerialize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.ShouldSerializeMeshData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMesh::ShouldSerializeMeshData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "ShouldSerializeMeshData");

	Params::RuntimeMesh_ShouldSerializeMeshData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.UpdateMeshSection_Blueprint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Normals                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRuntimeMeshTangent>&Tangents                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UV0                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UV1                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FLinearColor>&      Colors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCalculateNormalTangent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldCreateHardTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGenerateTessellationTriangles                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::UpdateMeshSection_Blueprint(int32 SectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, const TArray<struct FVector>& Normals, const TArray<struct FRuntimeMeshTangent>& Tangents, const TArray<struct FVector2D>& UV0, const TArray<struct FVector2D>& UV1, const TArray<struct FLinearColor>& Colors, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "UpdateMeshSection_Blueprint");

	Params::RuntimeMesh_UpdateMeshSection_Blueprint Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.Normals = std::move(Normals);
	Parms.Tangents = std::move(Tangents);
	Parms.UV0 = std::move(UV0);
	Parms.UV1 = std::move(UV1);
	Parms.Colors = std::move(Colors);
	Parms.bCalculateNormalTangent = bCalculateNormalTangent;
	Parms.bShouldCreateHardTangents = bShouldCreateHardTangents;
	Parms.bGenerateTessellationTriangles = bGenerateTessellationTriangles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.UpdateMeshSectionFromBuilder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeBlueprintMeshBuilder*     MeshData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::UpdateMeshSectionFromBuilder(int32 SectionID, class URuntimeBlueprintMeshBuilder* MeshData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "UpdateMeshSectionFromBuilder");

	Params::RuntimeMesh_UpdateMeshSectionFromBuilder Parms{};

	Parms.SectionID = SectionID;
	Parms.MeshData = MeshData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.UpdateMeshSectionPacked_Blueprint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRuntimeMeshBlueprintVertexSimple>&Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCalculateNormalTangent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldCreateHardTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGenerateTessellationTriangles                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::UpdateMeshSectionPacked_Blueprint(int32 SectionIndex, const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "UpdateMeshSectionPacked_Blueprint");

	Params::RuntimeMesh_UpdateMeshSectionPacked_Blueprint Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.bCalculateNormalTangent = bCalculateNormalTangent;
	Parms.bShouldCreateHardTangents = bShouldCreateHardTangents;
	Parms.bGenerateTessellationTriangles = bGenerateTessellationTriangles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMesh.DoesSectionExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMesh::DoesSectionExist(int32 SectionIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "DoesSectionExist");

	Params::RuntimeMesh_DoesSectionExist Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.GetAvailableSectionIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMesh::GetAvailableSectionIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "GetAvailableSectionIndex");

	Params::RuntimeMesh_GetAvailableSectionIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.GetCollisionMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERuntimeMeshCollisionCookingMode        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERuntimeMeshCollisionCookingMode URuntimeMesh::GetCollisionMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "GetCollisionMode");

	Params::RuntimeMesh_GetCollisionMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.GetMaterialFromCollisionFaceIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   FaceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  SectionIndex                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* URuntimeMesh::GetMaterialFromCollisionFaceIndex(int32 FaceIndex, int32* SectionIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "GetMaterialFromCollisionFaceIndex");

	Params::RuntimeMesh_GetMaterialFromCollisionFaceIndex Parms{};

	Parms.FaceIndex = FaceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SectionIndex != nullptr)
		*SectionIndex = Parms.SectionIndex;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.GetNumSections
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMesh::GetNumSections() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "GetNumSections");

	Params::RuntimeMesh_GetNumSections Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.GetSectionIdAndFaceIdFromCollisionFaceIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   FaceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  SectionIndex                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  SectionFaceIndex                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMesh::GetSectionIdAndFaceIdFromCollisionFaceIndex(int32 FaceIndex, int32* SectionIndex, int32* SectionFaceIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "GetSectionIdAndFaceIdFromCollisionFaceIndex");

	Params::RuntimeMesh_GetSectionIdAndFaceIdFromCollisionFaceIndex Parms{};

	Parms.FaceIndex = FaceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SectionIndex != nullptr)
		*SectionIndex = Parms.SectionIndex;

	if (SectionFaceIndex != nullptr)
		*SectionFaceIndex = Parms.SectionFaceIndex;
}


// Function RuntimeMeshComponent.RuntimeMesh.GetSectionIdFromCollisionFaceIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   FaceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMesh::GetSectionIdFromCollisionFaceIndex(int32 FaceIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "GetSectionIdFromCollisionFaceIndex");

	Params::RuntimeMesh_GetSectionIdFromCollisionFaceIndex Parms{};

	Parms.FaceIndex = FaceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.IsMeshSectionCastingShadows
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMesh::IsMeshSectionCastingShadows(int32 SectionIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "IsMeshSectionCastingShadows");

	Params::RuntimeMesh_IsMeshSectionCastingShadows Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMesh.IsMeshSectionVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMesh::IsMeshSectionVisible(int32 SectionIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMesh", "IsMeshSectionVisible");

	Params::RuntimeMesh_IsMeshSectionVisible Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshActor.GenerateMeshes
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ARuntimeMeshActor::GenerateMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshActor", "GenerateMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshActor.GetRuntimeMeshMobility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERuntimeMeshMobility                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERuntimeMeshMobility ARuntimeMeshActor::GetRuntimeMeshMobility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshActor", "GetRuntimeMeshMobility");

	Params::RuntimeMeshActor_GetRuntimeMeshMobility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshActor.SetRuntimeMeshMobility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERuntimeMeshMobility                    NewMobility                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMeshActor::SetRuntimeMeshMobility(ERuntimeMeshMobility NewMobility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshActor", "SetRuntimeMeshMobility");

	Params::RuntimeMeshActor_SetRuntimeMeshMobility Parms{};

	Parms.NewMobility = NewMobility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshBuilderFunctions.MakeRuntimeMeshBuilder
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bWantsHighPrecisionTangents                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWantsHighPrecisionUVs                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumUVs                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUse16BitIndices                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeBlueprintMeshBuilder*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URuntimeBlueprintMeshBuilder* URuntimeMeshBuilderFunctions::MakeRuntimeMeshBuilder(bool bWantsHighPrecisionTangents, bool bWantsHighPrecisionUVs, int32 NumUVs, bool bUse16BitIndices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshBuilderFunctions", "MakeRuntimeMeshBuilder");

	Params::RuntimeMeshBuilderFunctions_MakeRuntimeMeshBuilder Parms{};

	Parms.bWantsHighPrecisionTangents = bWantsHighPrecisionTangents;
	Parms.bWantsHighPrecisionUVs = bWantsHighPrecisionUVs;
	Parms.NumUVs = NumUVs;
	Parms.bUse16BitIndices = bUse16BitIndices;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.AddCollisionBox
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRuntimeMeshCollisionBox&  NewBox                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMeshComponent::AddCollisionBox(const struct FRuntimeMeshCollisionBox& NewBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "AddCollisionBox");

	Params::RuntimeMeshComponent_AddCollisionBox Parms{};

	Parms.NewBox = std::move(NewBox);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.AddCollisionCapsule
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRuntimeMeshCollisionCapsule&NewCapsule                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMeshComponent::AddCollisionCapsule(const struct FRuntimeMeshCollisionCapsule& NewCapsule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "AddCollisionCapsule");

	Params::RuntimeMeshComponent_AddCollisionCapsule Parms{};

	Parms.NewCapsule = std::move(NewCapsule);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.AddCollisionSphere
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRuntimeMeshCollisionSphere&NewSphere                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMeshComponent::AddCollisionSphere(const struct FRuntimeMeshCollisionSphere& NewSphere)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "AddCollisionSphere");

	Params::RuntimeMeshComponent_AddCollisionSphere Parms{};

	Parms.NewSphere = std::move(NewSphere);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.AddConvexCollisionSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           ConvexVerts                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMeshComponent::AddConvexCollisionSection(const TArray<struct FVector>& ConvexVerts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "AddConvexCollisionSection");

	Params::RuntimeMeshComponent_AddConvexCollisionSection Parms{};

	Parms.ConvexVerts = std::move(ConvexVerts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.ClearAllConvexCollisionSections
// (Final, Native, Public, BlueprintCallable)

void URuntimeMeshComponent::ClearAllConvexCollisionSections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "ClearAllConvexCollisionSections");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.ClearAllMeshCollisionSections
// (Final, Native, Public, BlueprintCallable)

void URuntimeMeshComponent::ClearAllMeshCollisionSections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "ClearAllMeshCollisionSections");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.ClearAllMeshSections
// (Final, Native, Public, BlueprintCallable)

void URuntimeMeshComponent::ClearAllMeshSections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "ClearAllMeshSections");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.ClearCollisionBoxes
// (Final, Native, Public, BlueprintCallable)

void URuntimeMeshComponent::ClearCollisionBoxes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "ClearCollisionBoxes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.ClearCollisionCapsules
// (Final, Native, Public, BlueprintCallable)

void URuntimeMeshComponent::ClearCollisionCapsules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "ClearCollisionCapsules");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.ClearCollisionSpheres
// (Final, Native, Public, BlueprintCallable)

void URuntimeMeshComponent::ClearCollisionSpheres()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "ClearCollisionSpheres");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.ClearConvexCollisionSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ConvexSectionIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::ClearConvexCollisionSection(int32 ConvexSectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "ClearConvexCollisionSection");

	Params::RuntimeMeshComponent_ClearConvexCollisionSection Parms{};

	Parms.ConvexSectionIndex = ConvexSectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.ClearMeshCollisionSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CollisionSectionIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::ClearMeshCollisionSection(int32 CollisionSectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "ClearMeshCollisionSection");

	Params::RuntimeMeshComponent_ClearMeshCollisionSection Parms{};

	Parms.CollisionSectionIndex = CollisionSectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.ClearMeshSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::ClearMeshSection(int32 SectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "ClearMeshSection");

	Params::RuntimeMeshComponent_ClearMeshSection Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.CookCollisionNow
// (Final, Native, Public, BlueprintCallable)

void URuntimeMeshComponent::CookCollisionNow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "CookCollisionNow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.CreateMeshSection_Blueprint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Normals                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRuntimeMeshTangent>&Tangents                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UV0                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UV1                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FLinearColor>&      Colors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCalculateNormalTangent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldCreateHardTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGenerateTessellationTriangles                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUpdateFrequency                        UpdateFrequency                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionUVs                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::CreateMeshSection_Blueprint(int32 SectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, const TArray<struct FVector>& Normals, const TArray<struct FRuntimeMeshTangent>& Tangents, const TArray<struct FVector2D>& UV0, const TArray<struct FVector2D>& UV1, const TArray<struct FLinearColor>& Colors, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "CreateMeshSection_Blueprint");

	Params::RuntimeMeshComponent_CreateMeshSection_Blueprint Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.Normals = std::move(Normals);
	Parms.Tangents = std::move(Tangents);
	Parms.UV0 = std::move(UV0);
	Parms.UV1 = std::move(UV1);
	Parms.Colors = std::move(Colors);
	Parms.bCreateCollision = bCreateCollision;
	Parms.bCalculateNormalTangent = bCalculateNormalTangent;
	Parms.bShouldCreateHardTangents = bShouldCreateHardTangents;
	Parms.bGenerateTessellationTriangles = bGenerateTessellationTriangles;
	Parms.UpdateFrequency = UpdateFrequency;
	Parms.bUseHighPrecisionTangents = bUseHighPrecisionTangents;
	Parms.bUseHighPrecisionUVs = bUseHighPrecisionUVs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.CreateMeshSectionFromBuilder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeBlueprintMeshBuilder*     MeshData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUpdateFrequency                        UpdateFrequency                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::CreateMeshSectionFromBuilder(int32 SectionID, class URuntimeBlueprintMeshBuilder* MeshData, bool bCreateCollision, EUpdateFrequency UpdateFrequency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "CreateMeshSectionFromBuilder");

	Params::RuntimeMeshComponent_CreateMeshSectionFromBuilder Parms{};

	Parms.SectionID = SectionID;
	Parms.MeshData = MeshData;
	Parms.bCreateCollision = bCreateCollision;
	Parms.UpdateFrequency = UpdateFrequency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.CreateMeshSectionPacked_Blueprint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRuntimeMeshBlueprintVertexSimple>&Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCalculateNormalTangent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldCreateHardTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGenerateTessellationTriangles                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUpdateFrequency                        UpdateFrequency                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionUVs                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::CreateMeshSectionPacked_Blueprint(int32 SectionIndex, const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "CreateMeshSectionPacked_Blueprint");

	Params::RuntimeMeshComponent_CreateMeshSectionPacked_Blueprint Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.bCreateCollision = bCreateCollision;
	Parms.bCalculateNormalTangent = bCalculateNormalTangent;
	Parms.bShouldCreateHardTangents = bShouldCreateHardTangents;
	Parms.bGenerateTessellationTriangles = bGenerateTessellationTriangles;
	Parms.UpdateFrequency = UpdateFrequency;
	Parms.bUseHighPrecisionTangents = bUseHighPrecisionTangents;
	Parms.bUseHighPrecisionUVs = bUseHighPrecisionUVs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.GetOrCreateRuntimeMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URuntimeMesh*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URuntimeMesh* URuntimeMeshComponent::GetOrCreateRuntimeMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "GetOrCreateRuntimeMesh");

	Params::RuntimeMeshComponent_GetOrCreateRuntimeMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.GetRuntimeMeshMobility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERuntimeMeshMobility                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERuntimeMeshMobility URuntimeMeshComponent::GetRuntimeMeshMobility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "GetRuntimeMeshMobility");

	Params::RuntimeMeshComponent_GetRuntimeMeshMobility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.GetSectionBoundingBox
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox URuntimeMeshComponent::GetSectionBoundingBox(int32 SectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "GetSectionBoundingBox");

	Params::RuntimeMeshComponent_GetSectionBoundingBox Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.GetSectionMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* URuntimeMeshComponent::GetSectionMaterial(int32 SectionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "GetSectionMaterial");

	Params::RuntimeMeshComponent_GetSectionMaterial Parms{};

	Parms.SectionID = SectionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.IsCollisionUsingAsyncCooking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMeshComponent::IsCollisionUsingAsyncCooking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "IsCollisionUsingAsyncCooking");

	Params::RuntimeMeshComponent_IsCollisionUsingAsyncCooking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.IsCollisionUsingComplexAsSimple
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMeshComponent::IsCollisionUsingComplexAsSimple()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "IsCollisionUsingComplexAsSimple");

	Params::RuntimeMeshComponent_IsCollisionUsingComplexAsSimple Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.IsMeshSectionCollisionEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMeshComponent::IsMeshSectionCollisionEnabled(int32 SectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "IsMeshSectionCollisionEnabled");

	Params::RuntimeMeshComponent_IsMeshSectionCollisionEnabled Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.RemoveCollisionBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::RemoveCollisionBox(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "RemoveCollisionBox");

	Params::RuntimeMeshComponent_RemoveCollisionBox Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.RemoveCollisionCapsule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::RemoveCollisionCapsule(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "RemoveCollisionCapsule");

	Params::RuntimeMeshComponent_RemoveCollisionCapsule Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.RemoveCollisionSphere
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::RemoveCollisionSphere(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "RemoveCollisionSphere");

	Params::RuntimeMeshComponent_RemoveCollisionSphere Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetCollisionBoxes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FRuntimeMeshCollisionBox>&NewBoxes                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetCollisionBoxes(const TArray<struct FRuntimeMeshCollisionBox>& NewBoxes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetCollisionBoxes");

	Params::RuntimeMeshComponent_SetCollisionBoxes Parms{};

	Parms.NewBoxes = std::move(NewBoxes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetCollisionCapsules
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FRuntimeMeshCollisionCapsule>&NewCapsules                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetCollisionCapsules(const TArray<struct FRuntimeMeshCollisionCapsule>& NewCapsules)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetCollisionCapsules");

	Params::RuntimeMeshComponent_SetCollisionCapsules Parms{};

	Parms.NewCapsules = std::move(NewCapsules);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetCollisionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERuntimeMeshCollisionCookingMode        NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetCollisionMode(ERuntimeMeshCollisionCookingMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetCollisionMode");

	Params::RuntimeMeshComponent_SetCollisionMode Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetCollisionSpheres
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FRuntimeMeshCollisionSphere>&NewSpheres                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetCollisionSpheres(const TArray<struct FRuntimeMeshCollisionSphere>& NewSpheres)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetCollisionSpheres");

	Params::RuntimeMeshComponent_SetCollisionSpheres Parms{};

	Parms.NewSpheres = std::move(NewSpheres);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetCollisionUseAsyncCooking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetCollisionUseAsyncCooking(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetCollisionUseAsyncCooking");

	Params::RuntimeMeshComponent_SetCollisionUseAsyncCooking Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetCollisionUseComplexAsSimple
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetCollisionUseComplexAsSimple(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetCollisionUseComplexAsSimple");

	Params::RuntimeMeshComponent_SetCollisionUseComplexAsSimple Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetConvexCollisionSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ConvexSectionIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           ConvexVerts                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetConvexCollisionSection(int32 ConvexSectionIndex, const TArray<struct FVector>& ConvexVerts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetConvexCollisionSection");

	Params::RuntimeMeshComponent_SetConvexCollisionSection Parms{};

	Parms.ConvexSectionIndex = ConvexSectionIndex;
	Parms.ConvexVerts = std::move(ConvexVerts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetMeshCollisionSection
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   CollisionSectionIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetMeshCollisionSection(int32 CollisionSectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetMeshCollisionSection");

	Params::RuntimeMeshComponent_SetMeshCollisionSection Parms{};

	Parms.CollisionSectionIndex = CollisionSectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetMeshSection_Blueprint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Normals                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRuntimeMeshTangent>&Tangents                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UV0                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UV1                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FLinearColor>&      Colors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCalculateNormalTangent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldCreateHardTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGenerateTessellationTriangles                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUpdateFrequency                        UpdateFrequency                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionUVs                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERuntimeMeshSetAction                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERuntimeMeshSetAction URuntimeMeshComponent::SetMeshSection_Blueprint(int32 SectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, const TArray<struct FVector>& Normals, const TArray<struct FRuntimeMeshTangent>& Tangents, const TArray<struct FVector2D>& UV0, const TArray<struct FVector2D>& UV1, const TArray<struct FLinearColor>& Colors, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetMeshSection_Blueprint");

	Params::RuntimeMeshComponent_SetMeshSection_Blueprint Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.Normals = std::move(Normals);
	Parms.Tangents = std::move(Tangents);
	Parms.UV0 = std::move(UV0);
	Parms.UV1 = std::move(UV1);
	Parms.Colors = std::move(Colors);
	Parms.bCreateCollision = bCreateCollision;
	Parms.bCalculateNormalTangent = bCalculateNormalTangent;
	Parms.bShouldCreateHardTangents = bShouldCreateHardTangents;
	Parms.bGenerateTessellationTriangles = bGenerateTessellationTriangles;
	Parms.UpdateFrequency = UpdateFrequency;
	Parms.bUseHighPrecisionTangents = bUseHighPrecisionTangents;
	Parms.bUseHighPrecisionUVs = bUseHighPrecisionUVs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetMeshSectionCastsShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewCastsShadow                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetMeshSectionCastsShadow(int32 SectionIndex, bool bNewCastsShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetMeshSectionCastsShadow");

	Params::RuntimeMeshComponent_SetMeshSectionCastsShadow Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.bNewCastsShadow = bNewCastsShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetMeshSectionCollisionEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewCollisionEnabled                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetMeshSectionCollisionEnabled(int32 SectionIndex, bool bNewCollisionEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetMeshSectionCollisionEnabled");

	Params::RuntimeMeshComponent_SetMeshSectionCollisionEnabled Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.bNewCollisionEnabled = bNewCollisionEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetMeshSectionPacked_Blueprint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRuntimeMeshBlueprintVertexSimple>&Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCalculateNormalTangent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldCreateHardTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGenerateTessellationTriangles                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUpdateFrequency                        UpdateFrequency                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseHighPrecisionUVs                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERuntimeMeshSetAction                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERuntimeMeshSetAction URuntimeMeshComponent::SetMeshSectionPacked_Blueprint(int32 SectionIndex, const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetMeshSectionPacked_Blueprint");

	Params::RuntimeMeshComponent_SetMeshSectionPacked_Blueprint Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.bCreateCollision = bCreateCollision;
	Parms.bCalculateNormalTangent = bCalculateNormalTangent;
	Parms.bShouldCreateHardTangents = bShouldCreateHardTangents;
	Parms.bGenerateTessellationTriangles = bGenerateTessellationTriangles;
	Parms.UpdateFrequency = UpdateFrequency;
	Parms.bUseHighPrecisionTangents = bUseHighPrecisionTangents;
	Parms.bUseHighPrecisionUVs = bUseHighPrecisionUVs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetMeshSectionVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetMeshSectionVisible(int32 SectionIndex, bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetMeshSectionVisible");

	Params::RuntimeMeshComponent_SetMeshSectionVisible Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.bNewVisibility = bNewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetRuntimeMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URuntimeMesh*                     NewMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetRuntimeMesh(class URuntimeMesh* NewMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetRuntimeMesh");

	Params::RuntimeMeshComponent_SetRuntimeMesh Parms{};

	Parms.NewMesh = NewMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetRuntimeMeshMobility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERuntimeMeshMobility                    NewMobility                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetRuntimeMeshMobility(ERuntimeMeshMobility NewMobility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetRuntimeMeshMobility");

	Params::RuntimeMeshComponent_SetRuntimeMeshMobility Parms{};

	Parms.NewMobility = NewMobility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetSectionMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetSectionMaterial(int32 SectionID, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetSectionMaterial");

	Params::RuntimeMeshComponent_SetSectionMaterial Parms{};

	Parms.SectionID = SectionID;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.SetShouldSerializeMeshData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldSerialize                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::SetShouldSerializeMeshData(bool bShouldSerialize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "SetShouldSerializeMeshData");

	Params::RuntimeMeshComponent_SetShouldSerializeMeshData Parms{};

	Parms.bShouldSerialize = bShouldSerialize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.ShouldSerializeMeshData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMeshComponent::ShouldSerializeMeshData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "ShouldSerializeMeshData");

	Params::RuntimeMeshComponent_ShouldSerializeMeshData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.UpdateMeshSection_Blueprint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Normals                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRuntimeMeshTangent>&Tangents                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UV0                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UV1                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FLinearColor>&      Colors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCalculateNormalTangent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldCreateHardTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGenerateTessellationTriangles                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::UpdateMeshSection_Blueprint(int32 SectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, const TArray<struct FVector>& Normals, const TArray<struct FRuntimeMeshTangent>& Tangents, const TArray<struct FVector2D>& UV0, const TArray<struct FVector2D>& UV1, const TArray<struct FLinearColor>& Colors, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "UpdateMeshSection_Blueprint");

	Params::RuntimeMeshComponent_UpdateMeshSection_Blueprint Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.Normals = std::move(Normals);
	Parms.Tangents = std::move(Tangents);
	Parms.UV0 = std::move(UV0);
	Parms.UV1 = std::move(UV1);
	Parms.Colors = std::move(Colors);
	Parms.bCalculateNormalTangent = bCalculateNormalTangent;
	Parms.bShouldCreateHardTangents = bShouldCreateHardTangents;
	Parms.bGenerateTessellationTriangles = bGenerateTessellationTriangles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.UpdateMeshSectionFromBuilder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SectionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeBlueprintMeshBuilder*     MeshData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::UpdateMeshSectionFromBuilder(int32 SectionID, class URuntimeBlueprintMeshBuilder* MeshData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "UpdateMeshSectionFromBuilder");

	Params::RuntimeMeshComponent_UpdateMeshSectionFromBuilder Parms{};

	Parms.SectionID = SectionID;
	Parms.MeshData = MeshData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.UpdateMeshSectionPacked_Blueprint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRuntimeMeshBlueprintVertexSimple>&Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCalculateNormalTangent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldCreateHardTangents                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGenerateTessellationTriangles                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::UpdateMeshSectionPacked_Blueprint(int32 SectionIndex, const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "UpdateMeshSectionPacked_Blueprint");

	Params::RuntimeMeshComponent_UpdateMeshSectionPacked_Blueprint Parms{};

	Parms.SectionIndex = SectionIndex;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.bCalculateNormalTangent = bCalculateNormalTangent;
	Parms.bShouldCreateHardTangents = bShouldCreateHardTangents;
	Parms.bGenerateTessellationTriangles = bGenerateTessellationTriangles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.DoesSectionExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMeshComponent::DoesSectionExist(int32 SectionIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "DoesSectionExist");

	Params::RuntimeMeshComponent_DoesSectionExist Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.GetAvailableSectionIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMeshComponent::GetAvailableSectionIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "GetAvailableSectionIndex");

	Params::RuntimeMeshComponent_GetAvailableSectionIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.GetNumSections
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMeshComponent::GetNumSections() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "GetNumSections");

	Params::RuntimeMeshComponent_GetNumSections Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.GetRuntimeMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URuntimeMesh*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URuntimeMesh* URuntimeMeshComponent::GetRuntimeMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "GetRuntimeMesh");

	Params::RuntimeMeshComponent_GetRuntimeMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.GetSectionIdAndFaceIdFromCollisionFaceIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   FaceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  SectionIndex                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  SectionFaceIndex                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshComponent::GetSectionIdAndFaceIdFromCollisionFaceIndex(int32 FaceIndex, int32* SectionIndex, int32* SectionFaceIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "GetSectionIdAndFaceIdFromCollisionFaceIndex");

	Params::RuntimeMeshComponent_GetSectionIdAndFaceIdFromCollisionFaceIndex Parms{};

	Parms.FaceIndex = FaceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SectionIndex != nullptr)
		*SectionIndex = Parms.SectionIndex;

	if (SectionFaceIndex != nullptr)
		*SectionFaceIndex = Parms.SectionFaceIndex;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.GetSectionIdFromCollisionFaceIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   FaceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMeshComponent::GetSectionIdFromCollisionFaceIndex(int32 FaceIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "GetSectionIdFromCollisionFaceIndex");

	Params::RuntimeMeshComponent_GetSectionIdFromCollisionFaceIndex Parms{};

	Parms.FaceIndex = FaceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.IsAsyncCollisionCookingPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMeshComponent::IsAsyncCollisionCookingPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "IsAsyncCollisionCookingPending");

	Params::RuntimeMeshComponent_IsAsyncCollisionCookingPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.IsMeshSectionCastingShadows
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMeshComponent::IsMeshSectionCastingShadows(int32 SectionIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "IsMeshSectionCastingShadows");

	Params::RuntimeMeshComponent_IsMeshSectionCastingShadows Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshComponent.IsMeshSectionVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMeshComponent::IsMeshSectionVisible(int32 SectionIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMeshComponent", "IsMeshSectionVisible");

	Params::RuntimeMeshComponent_IsMeshSectionVisible Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshLibrary.CalculateTangentsForMesh
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Normals                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UVs                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRuntimeMeshTangent>*     Tangents                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateSmoothNormals                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshLibrary::CalculateTangentsForMesh(const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, TArray<struct FVector>* Normals, const TArray<struct FVector2D>& UVs, TArray<struct FRuntimeMeshTangent>* Tangents, bool bCreateSmoothNormals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshLibrary", "CalculateTangentsForMesh");

	Params::RuntimeMeshLibrary_CalculateTangentsForMesh Parms{};

	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.UVs = std::move(UVs);
	Parms.bCreateSmoothNormals = bCreateSmoothNormals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Normals != nullptr)
		*Normals = std::move(Parms.Normals);

	if (Tangents != nullptr)
		*Tangents = std::move(Parms.Tangents);
}


// Function RuntimeMeshComponent.RuntimeMeshLibrary.CalculateTangentsForMeshPacked
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FRuntimeMeshBlueprintVertexSimple>*Vertices                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateSmoothNormals                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshLibrary::CalculateTangentsForMeshPacked(TArray<struct FRuntimeMeshBlueprintVertexSimple>* Vertices, const TArray<int32>& Triangles, bool bCreateSmoothNormals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshLibrary", "CalculateTangentsForMeshPacked");

	Params::RuntimeMeshLibrary_CalculateTangentsForMeshPacked Parms{};

	Parms.Triangles = std::move(Triangles);
	Parms.bCreateSmoothNormals = bCreateSmoothNormals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Vertices != nullptr)
		*Vertices = std::move(Parms.Vertices);
}


// Function RuntimeMeshComponent.RuntimeMeshLibrary.CopyCollisionFromStaticMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeMesh*                     RuntimeMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshLibrary::CopyCollisionFromStaticMesh(class UStaticMesh* StaticMesh, class URuntimeMesh* RuntimeMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshLibrary", "CopyCollisionFromStaticMesh");

	Params::RuntimeMeshLibrary_CopyCollisionFromStaticMesh Parms{};

	Parms.StaticMesh = StaticMesh;
	Parms.RuntimeMesh = RuntimeMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshLibrary.CopyStaticMeshToRuntimeMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeMesh*                     RuntimeMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshLibrary::CopyStaticMeshToRuntimeMesh(class UStaticMeshComponent* StaticMeshComponent, int32 LODIndex, class URuntimeMesh* RuntimeMesh, bool bCreateCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshLibrary", "CopyStaticMeshToRuntimeMesh");

	Params::RuntimeMeshLibrary_CopyStaticMeshToRuntimeMesh Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.LODIndex = LODIndex;
	Parms.RuntimeMesh = RuntimeMesh;
	Parms.bCreateCollision = bCreateCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshLibrary.CopyStaticMeshToRuntimeMeshComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeMeshComponent*            RuntimeMeshComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateCollision                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshLibrary::CopyStaticMeshToRuntimeMeshComponent(class UStaticMeshComponent* StaticMeshComponent, int32 LODIndex, class URuntimeMeshComponent* RuntimeMeshComponent, bool bCreateCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshLibrary", "CopyStaticMeshToRuntimeMeshComponent");

	Params::RuntimeMeshLibrary_CopyStaticMeshToRuntimeMeshComponent Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.LODIndex = LODIndex;
	Parms.RuntimeMeshComponent = RuntimeMeshComponent;
	Parms.bCreateCollision = bCreateCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshLibrary.CopyStaticMeshToRuntimeMeshComponentWithoutCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               MaterialInterface                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeMeshComponent*            RuntimeMeshComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshLibrary::CopyStaticMeshToRuntimeMeshComponentWithoutCollision(class UStaticMeshComponent* StaticMeshComponent, int32 LODIndex, class UMaterialInterface* MaterialInterface, class URuntimeMeshComponent* RuntimeMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshLibrary", "CopyStaticMeshToRuntimeMeshComponentWithoutCollision");

	Params::RuntimeMeshLibrary_CopyStaticMeshToRuntimeMeshComponentWithoutCollision Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.LODIndex = LODIndex;
	Parms.MaterialInterface = MaterialInterface;
	Parms.RuntimeMeshComponent = RuntimeMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshLibrary.GenerateTessellationIndexBuffer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Normals                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector2D>&         UVs                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRuntimeMeshTangent>*     Tangents                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<int32> URuntimeMeshLibrary::GenerateTessellationIndexBuffer(const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, TArray<struct FVector>* Normals, const TArray<struct FVector2D>& UVs, TArray<struct FRuntimeMeshTangent>* Tangents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshLibrary", "GenerateTessellationIndexBuffer");

	Params::RuntimeMeshLibrary_GenerateTessellationIndexBuffer Parms{};

	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.UVs = std::move(UVs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Normals != nullptr)
		*Normals = std::move(Parms.Normals);

	if (Tangents != nullptr)
		*Tangents = std::move(Parms.Tangents);

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshLibrary.GenerateTessellationIndexBufferPacked
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FRuntimeMeshBlueprintVertexSimple>&Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Triangles                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<int32> URuntimeMeshLibrary::GenerateTessellationIndexBufferPacked(const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshLibrary", "GenerateTessellationIndexBufferPacked");

	Params::RuntimeMeshLibrary_GenerateTessellationIndexBufferPacked Parms{};

	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeMeshComponent.RuntimeMeshLibrary.GetStaticMeshSection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Vertices                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          Triangles                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Normals                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>*               UVs                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FColor>*                  Colors                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRuntimeMeshTangent>*     Tangents                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshLibrary::GetStaticMeshSection(class UStaticMesh* InMesh, int32 LODIndex, int32 SectionIndex, TArray<struct FVector>* Vertices, TArray<int32>* Triangles, TArray<struct FVector>* Normals, TArray<struct FVector2D>* UVs, TArray<struct FColor>* Colors, TArray<struct FRuntimeMeshTangent>* Tangents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshLibrary", "GetStaticMeshSection");

	Params::RuntimeMeshLibrary_GetStaticMeshSection Parms{};

	Parms.InMesh = InMesh;
	Parms.LODIndex = LODIndex;
	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Vertices != nullptr)
		*Vertices = std::move(Parms.Vertices);

	if (Triangles != nullptr)
		*Triangles = std::move(Parms.Triangles);

	if (Normals != nullptr)
		*Normals = std::move(Parms.Normals);

	if (UVs != nullptr)
		*UVs = std::move(Parms.UVs);

	if (Colors != nullptr)
		*Colors = std::move(Parms.Colors);

	if (Tangents != nullptr)
		*Tangents = std::move(Parms.Tangents);
}


// Function RuntimeMeshComponent.RuntimeMeshLibrary.GetStaticMeshSectionPacked
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRuntimeMeshBlueprintVertexSimple>*Vertices                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          Triangles                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshLibrary::GetStaticMeshSectionPacked(class UStaticMesh* InMesh, int32 LODIndex, int32 SectionIndex, TArray<struct FRuntimeMeshBlueprintVertexSimple>* Vertices, TArray<int32>* Triangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshLibrary", "GetStaticMeshSectionPacked");

	Params::RuntimeMeshLibrary_GetStaticMeshSectionPacked Parms{};

	Parms.InMesh = InMesh;
	Parms.LODIndex = LODIndex;
	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Vertices != nullptr)
		*Vertices = std::move(Parms.Vertices);

	if (Triangles != nullptr)
		*Triangles = std::move(Parms.Triangles);
}


// Function RuntimeMeshComponent.RuntimeMeshShapeGenerator.ConvertQuadToTriangles
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>&                          Triangles                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Vert0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Vert1                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Vert2                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Vert3                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshShapeGenerator::ConvertQuadToTriangles(TArray<int32>& Triangles, int32 Vert0, int32 Vert1, int32 Vert2, int32 Vert3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshShapeGenerator", "ConvertQuadToTriangles");

	Params::RuntimeMeshShapeGenerator_ConvertQuadToTriangles Parms{};

	Parms.Triangles = std::move(Triangles);
	Parms.Vert0 = Vert0;
	Parms.Vert1 = Vert1;
	Parms.Vert2 = Vert2;
	Parms.Vert3 = Vert3;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Triangles = std::move(Parms.Triangles);
}


// Function RuntimeMeshComponent.RuntimeMeshShapeGenerator.CreateBoxMesh
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   BoxRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Vertices                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          Triangles                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Normals                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>*               UVs                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRuntimeMeshTangent>*     Tangents                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshShapeGenerator::CreateBoxMesh(const struct FVector& BoxRadius, TArray<struct FVector>* Vertices, TArray<int32>* Triangles, TArray<struct FVector>* Normals, TArray<struct FVector2D>* UVs, TArray<struct FRuntimeMeshTangent>* Tangents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshShapeGenerator", "CreateBoxMesh");

	Params::RuntimeMeshShapeGenerator_CreateBoxMesh Parms{};

	Parms.BoxRadius = std::move(BoxRadius);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Vertices != nullptr)
		*Vertices = std::move(Parms.Vertices);

	if (Triangles != nullptr)
		*Triangles = std::move(Parms.Triangles);

	if (Normals != nullptr)
		*Normals = std::move(Parms.Normals);

	if (UVs != nullptr)
		*UVs = std::move(Parms.UVs);

	if (Tangents != nullptr)
		*Tangents = std::move(Parms.Tangents);
}


// Function RuntimeMeshComponent.RuntimeMeshShapeGenerator.CreateBoxMeshPacked
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   BoxRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRuntimeMeshBlueprintVertexSimple>*Vertices                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          Triangles                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshShapeGenerator::CreateBoxMeshPacked(const struct FVector& BoxRadius, TArray<struct FRuntimeMeshBlueprintVertexSimple>* Vertices, TArray<int32>* Triangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshShapeGenerator", "CreateBoxMeshPacked");

	Params::RuntimeMeshShapeGenerator_CreateBoxMeshPacked Parms{};

	Parms.BoxRadius = std::move(BoxRadius);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Vertices != nullptr)
		*Vertices = std::move(Parms.Vertices);

	if (Triangles != nullptr)
		*Triangles = std::move(Parms.Triangles);
}


// Function RuntimeMeshComponent.RuntimeMeshShapeGenerator.CreateGridMesh
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumSubdivisionsX                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumSubdivisionsY                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Vertices                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          Triangles                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Normals                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>*               UVs                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRuntimeMeshTangent>*     Tangents                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshShapeGenerator::CreateGridMesh(float Width, float Height, int32 NumSubdivisionsX, int32 NumSubdivisionsY, TArray<struct FVector>* Vertices, TArray<int32>* Triangles, TArray<struct FVector>* Normals, TArray<struct FVector2D>* UVs, TArray<struct FRuntimeMeshTangent>* Tangents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshShapeGenerator", "CreateGridMesh");

	Params::RuntimeMeshShapeGenerator_CreateGridMesh Parms{};

	Parms.Width = Width;
	Parms.Height = Height;
	Parms.NumSubdivisionsX = NumSubdivisionsX;
	Parms.NumSubdivisionsY = NumSubdivisionsY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Vertices != nullptr)
		*Vertices = std::move(Parms.Vertices);

	if (Triangles != nullptr)
		*Triangles = std::move(Parms.Triangles);

	if (Normals != nullptr)
		*Normals = std::move(Parms.Normals);

	if (UVs != nullptr)
		*UVs = std::move(Parms.UVs);

	if (Tangents != nullptr)
		*Tangents = std::move(Parms.Tangents);
}


// Function RuntimeMeshComponent.RuntimeMeshShapeGenerator.CreateGridMeshPacked
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumSubdivisionsX                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumSubdivisionsY                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRuntimeMeshBlueprintVertexSimple>*Vertices                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          Triangles                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshShapeGenerator::CreateGridMeshPacked(float Width, float Height, int32 NumSubdivisionsX, int32 NumSubdivisionsY, TArray<struct FRuntimeMeshBlueprintVertexSimple>* Vertices, TArray<int32>* Triangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshShapeGenerator", "CreateGridMeshPacked");

	Params::RuntimeMeshShapeGenerator_CreateGridMeshPacked Parms{};

	Parms.Width = Width;
	Parms.Height = Height;
	Parms.NumSubdivisionsX = NumSubdivisionsX;
	Parms.NumSubdivisionsY = NumSubdivisionsY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Vertices != nullptr)
		*Vertices = std::move(Parms.Vertices);

	if (Triangles != nullptr)
		*Triangles = std::move(Parms.Triangles);
}


// Function RuntimeMeshComponent.RuntimeMeshShapeGenerator.CreateGridMeshTriangles
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   NumX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWinding                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          Triangles                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshShapeGenerator::CreateGridMeshTriangles(int32 NumX, int32 NumY, bool bWinding, TArray<int32>* Triangles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshShapeGenerator", "CreateGridMeshTriangles");

	Params::RuntimeMeshShapeGenerator_CreateGridMeshTriangles Parms{};

	Parms.NumX = NumX;
	Parms.NumY = NumY;
	Parms.bWinding = bWinding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Triangles != nullptr)
		*Triangles = std::move(Parms.Triangles);
}


// Function RuntimeMeshComponent.RuntimeMeshSlicer.SliceRuntimeMesh
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeMesh*                     InRuntimeMesh                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   PlanePosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   PlaneNormal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeMesh*                     OutOtherHalf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERuntimeMeshSlicerCapOption             CapOption                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               CapMaterial                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshSlicer::SliceRuntimeMesh(class URuntimeMesh* InRuntimeMesh, const struct FVector& PlanePosition, const struct FVector& PlaneNormal, class URuntimeMesh* OutOtherHalf, ERuntimeMeshSlicerCapOption CapOption, class UMaterialInterface* CapMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshSlicer", "SliceRuntimeMesh");

	Params::RuntimeMeshSlicer_SliceRuntimeMesh Parms{};

	Parms.InRuntimeMesh = InRuntimeMesh;
	Parms.PlanePosition = std::move(PlanePosition);
	Parms.PlaneNormal = std::move(PlaneNormal);
	Parms.OutOtherHalf = OutOtherHalf;
	Parms.CapOption = CapOption;
	Parms.CapMaterial = CapMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeMeshComponent.RuntimeMeshSlicer.SliceRuntimeMeshComponent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class URuntimeMeshComponent*            InRuntimeMesh                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   PlanePosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   PlaneNormal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateOtherHalf                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeMeshComponent**           OutOtherHalf                                           (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERuntimeMeshSlicerCapOption             CapOption                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               CapMaterial                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeMeshSlicer::SliceRuntimeMeshComponent(class URuntimeMeshComponent* InRuntimeMesh, const struct FVector& PlanePosition, const struct FVector& PlaneNormal, bool bCreateOtherHalf, class URuntimeMeshComponent** OutOtherHalf, ERuntimeMeshSlicerCapOption CapOption, class UMaterialInterface* CapMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMeshSlicer", "SliceRuntimeMeshComponent");

	Params::RuntimeMeshSlicer_SliceRuntimeMeshComponent Parms{};

	Parms.InRuntimeMesh = InRuntimeMesh;
	Parms.PlanePosition = std::move(PlanePosition);
	Parms.PlaneNormal = std::move(PlaneNormal);
	Parms.bCreateOtherHalf = bCreateOtherHalf;
	Parms.CapOption = CapOption;
	Parms.CapMaterial = CapMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOtherHalf != nullptr)
		*OutOtherHalf = Parms.OutOtherHalf;
}

}

