#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: HotPatcherRuntime

#include "Basic.hpp"

#include "HotPatcherRuntime_classes.hpp"
#include "HotPatcherRuntime_parameters.hpp"


namespace SDK
{

// Function HotPatcherRuntime.FlibAssetManageHelper.CombineAssetDependencies
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAssetDependenciesInfo&    A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAssetDependenciesInfo&    B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAssetDependenciesInfo           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAssetDependenciesInfo UFlibAssetManageHelper::CombineAssetDependencies(const struct FAssetDependenciesInfo& A, const struct FAssetDependenciesInfo& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "CombineAssetDependencies");

	Params::FlibAssetManageHelper_CombineAssetDependencies Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.CombineAssetsDetailAsFAssetDepenInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FAssetDetail>&      InAssetsDetailList                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAssetDependenciesInfo*          OutAssetInfo                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::CombineAssetsDetailAsFAssetDepenInfo(const TArray<struct FAssetDetail>& InAssetsDetailList, struct FAssetDependenciesInfo* OutAssetInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "CombineAssetsDetailAsFAssetDepenInfo");

	Params::FlibAssetManageHelper_CombineAssetsDetailAsFAssetDepenInfo Parms{};

	Parms.InAssetsDetailList = std::move(InAssetsDetailList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAssetInfo != nullptr)
		*OutAssetInfo = std::move(Parms.OutAssetInfo);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.ConvLongPackageNameToCookedPath
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InProjectAbsDir                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InPlatformName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InLongPackageName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>*                  OutCookedAssetPath                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>*                  OutCookedAssetRelativePath                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    OverrideCookedDir                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::ConvLongPackageNameToCookedPath(const class FString& InProjectAbsDir, const class FString& InPlatformName, const class FString& InLongPackageName, TArray<class FString>* OutCookedAssetPath, TArray<class FString>* OutCookedAssetRelativePath, const class FString& OverrideCookedDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "ConvLongPackageNameToCookedPath");

	Params::FlibAssetManageHelper_ConvLongPackageNameToCookedPath Parms{};

	Parms.InProjectAbsDir = std::move(InProjectAbsDir);
	Parms.InPlatformName = std::move(InPlatformName);
	Parms.InLongPackageName = std::move(InLongPackageName);
	Parms.OverrideCookedDir = std::move(OverrideCookedDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCookedAssetPath != nullptr)
		*OutCookedAssetPath = std::move(Parms.OutCookedAssetPath);

	if (OutCookedAssetRelativePath != nullptr)
		*OutCookedAssetRelativePath = std::move(Parms.OutCookedAssetRelativePath);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.ConvRelativeDirToAbsDir
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InRelativePath                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutAbsPath                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::ConvRelativeDirToAbsDir(const class FString& InRelativePath, class FString* OutAbsPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "ConvRelativeDirToAbsDir");

	Params::FlibAssetManageHelper_ConvRelativeDirToAbsDir Parms{};

	Parms.InRelativePath = std::move(InRelativePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAbsPath != nullptr)
		*OutAbsPath = std::move(Parms.OutAbsPath);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.ExportCookPakCommandToFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            InCommand                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InFile                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::ExportCookPakCommandToFile(const TArray<class FString>& InCommand, const class FString& InFile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "ExportCookPakCommandToFile");

	Params::FlibAssetManageHelper_ExportCookPakCommandToFile Parms{};

	Parms.InCommand = std::move(InCommand);
	Parms.InFile = std::move(InFile);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.FilenameToPackagePath
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InAbsPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutPackagePath                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::FilenameToPackagePath(const class FString& InAbsPath, class FString* OutPackagePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "FilenameToPackagePath");

	Params::FlibAssetManageHelper_FilenameToPackagePath Parms{};

	Parms.InAbsPath = std::move(InAbsPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPackagePath != nullptr)
		*OutPackagePath = std::move(Parms.OutPackagePath);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.FilterNoRefAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FAssetDetail>&      InAssetsDetail                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAssetDetail>*            OutHasRefAssetsDetail                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAssetDetail>*            OutDontHasRefAssetsDetail                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlibAssetManageHelper::FilterNoRefAssets(const TArray<struct FAssetDetail>& InAssetsDetail, TArray<struct FAssetDetail>* OutHasRefAssetsDetail, TArray<struct FAssetDetail>* OutDontHasRefAssetsDetail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "FilterNoRefAssets");

	Params::FlibAssetManageHelper_FilterNoRefAssets Parms{};

	Parms.InAssetsDetail = std::move(InAssetsDetail);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHasRefAssetsDetail != nullptr)
		*OutHasRefAssetsDetail = std::move(Parms.OutHasRefAssetsDetail);

	if (OutDontHasRefAssetsDetail != nullptr)
		*OutDontHasRefAssetsDetail = std::move(Parms.OutDontHasRefAssetsDetail);
}


// Function HotPatcherRuntime.FlibAssetManageHelper.FilterNoRefAssetsWithIgnoreFilter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FAssetDetail>&      InAssetsDetail                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            InIgnoreFilters                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAssetDetail>*            OutHasRefAssetsDetail                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAssetDetail>*            OutDontHasRefAssetsDetail                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlibAssetManageHelper::FilterNoRefAssetsWithIgnoreFilter(const TArray<struct FAssetDetail>& InAssetsDetail, const TArray<class FString>& InIgnoreFilters, TArray<struct FAssetDetail>* OutHasRefAssetsDetail, TArray<struct FAssetDetail>* OutDontHasRefAssetsDetail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "FilterNoRefAssetsWithIgnoreFilter");

	Params::FlibAssetManageHelper_FilterNoRefAssetsWithIgnoreFilter Parms{};

	Parms.InAssetsDetail = std::move(InAssetsDetail);
	Parms.InIgnoreFilters = std::move(InIgnoreFilters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHasRefAssetsDetail != nullptr)
		*OutHasRefAssetsDetail = std::move(Parms.OutHasRefAssetsDetail);

	if (OutDontHasRefAssetsDetail != nullptr)
		*OutDontHasRefAssetsDetail = std::move(Parms.OutDontHasRefAssetsDetail);
}


// Function HotPatcherRuntime.FlibAssetManageHelper.FindFilesRecursive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InStartDir                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>*                  OutFileList                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InRecursive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::FindFilesRecursive(const class FString& InStartDir, TArray<class FString>* OutFileList, bool InRecursive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "FindFilesRecursive");

	Params::FlibAssetManageHelper_FindFilesRecursive Parms{};

	Parms.InStartDir = std::move(InStartDir);
	Parms.InRecursive = InRecursive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFileList != nullptr)
		*OutFileList = std::move(Parms.OutFileList);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.GetAllEnabledModuleName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<class FString, class FString>*     OutModules                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UFlibAssetManageHelper::GetAllEnabledModuleName(TMap<class FString, class FString>* OutModules)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "GetAllEnabledModuleName");

	Params::FlibAssetManageHelper_GetAllEnabledModuleName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutModules != nullptr)
		*OutModules = std::move(Parms.OutModules);
}


// Function HotPatcherRuntime.FlibAssetManageHelper.GetAssetPackageGUID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InPackageName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            OutGUID                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::GetAssetPackageGUID(const class FString& InPackageName, class FName* OutGUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "GetAssetPackageGUID");

	Params::FlibAssetManageHelper_GetAssetPackageGUID Parms{};

	Parms.InPackageName = std::move(InPackageName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGUID != nullptr)
		*OutGUID = Parms.OutGUID;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.GetAssetReferenceEx
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAssetDetail&              InAsset                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<EAssetRegistryDependencyTypeEx>&SearchAssetDepTypes                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAssetDetail>*            OutRefAsset                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::GetAssetReferenceEx(const struct FAssetDetail& InAsset, const TArray<EAssetRegistryDependencyTypeEx>& SearchAssetDepTypes, TArray<struct FAssetDetail>* OutRefAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "GetAssetReferenceEx");

	Params::FlibAssetManageHelper_GetAssetReferenceEx Parms{};

	Parms.InAsset = std::move(InAsset);
	Parms.SearchAssetDepTypes = std::move(SearchAssetDepTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRefAsset != nullptr)
		*OutRefAsset = std::move(Parms.OutRefAsset);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.GetEnableModuleAbsDir
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InModuleName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutPath                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::GetEnableModuleAbsDir(const class FString& InModuleName, class FString* OutPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "GetEnableModuleAbsDir");

	Params::FlibAssetManageHelper_GetEnableModuleAbsDir Parms{};

	Parms.InModuleName = std::move(InModuleName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.GetModuleNameByRelativePath
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InRelativePath                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutModuleName                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::GetModuleNameByRelativePath(const class FString& InRelativePath, class FString* OutModuleName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "GetModuleNameByRelativePath");

	Params::FlibAssetManageHelper_GetModuleNameByRelativePath Parms{};

	Parms.InRelativePath = std::move(InRelativePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutModuleName != nullptr)
		*OutModuleName = std::move(Parms.OutModuleName);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.GetPluginModuleAbsDir
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InPluginModuleName                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutPath                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::GetPluginModuleAbsDir(const class FString& InPluginModuleName, class FString* OutPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "GetPluginModuleAbsDir");

	Params::FlibAssetManageHelper_GetPluginModuleAbsDir Parms{};

	Parms.InPluginModuleName = std::move(InPluginModuleName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.GetRedirectorList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FString>&            InFilterPackagePaths                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAssetDetail>*            OutRedirector                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::GetRedirectorList(const TArray<class FString>& InFilterPackagePaths, TArray<struct FAssetDetail>* OutRedirector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "GetRedirectorList");

	Params::FlibAssetManageHelper_GetRedirectorList Parms{};

	Parms.InFilterPackagePaths = std::move(InFilterPackagePaths);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRedirector != nullptr)
		*OutRedirector = std::move(Parms.OutRedirector);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.GetSpecifyAssetDetail
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    InLongPackageName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAssetDetail*                    OutAssetDetail                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::GetSpecifyAssetDetail(const class FString& InLongPackageName, struct FAssetDetail* OutAssetDetail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "GetSpecifyAssetDetail");

	Params::FlibAssetManageHelper_GetSpecifyAssetDetail Parms{};

	Parms.InLongPackageName = std::move(InLongPackageName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAssetDetail != nullptr)
		*OutAssetDetail = std::move(Parms.OutAssetDetail);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.LoadFileToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InFile                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutString                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::LoadFileToString(const class FString& InFile, class FString* OutString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "LoadFileToString");

	Params::FlibAssetManageHelper_LoadFileToString Parms{};

	Parms.InFile = std::move(InFile);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutString != nullptr)
		*OutString = std::move(Parms.OutString);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.LongPackageNameToFilename
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InLongPackageName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlibAssetManageHelper::LongPackageNameToFilename(const class FString& InLongPackageName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "LongPackageNameToFilename");

	Params::FlibAssetManageHelper_LongPackageNameToFilename Parms{};

	Parms.InLongPackageName = std::move(InLongPackageName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.LongPackageNameToPackagePath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InLongPackageName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlibAssetManageHelper::LongPackageNameToPackagePath(const class FString& InLongPackageName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "LongPackageNameToPackagePath");

	Params::FlibAssetManageHelper_LongPackageNameToPackagePath Parms{};

	Parms.InLongPackageName = std::move(InLongPackageName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.ModuleIsEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InModuleName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::ModuleIsEnabled(const class FString& InModuleName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "ModuleIsEnabled");

	Params::FlibAssetManageHelper_ModuleIsEnabled Parms{};

	Parms.InModuleName = std::move(InModuleName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.PackagePathToFilename
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InPackagePath                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlibAssetManageHelper::PackagePathToFilename(const class FString& InPackagePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "PackagePathToFilename");

	Params::FlibAssetManageHelper_PackagePathToFilename Parms{};

	Parms.InPackagePath = std::move(InPackagePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibAssetManageHelper.SaveStringToFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InFile                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibAssetManageHelper::SaveStringToFile(const class FString& InFile, const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibAssetManageHelper", "SaveStringToFile");

	Params::FlibAssetManageHelper_SaveStringToFile Parms{};

	Parms.InFile = std::move(InFile);
	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.CloseShaderbytecode
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    LibraryName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlibPakHelper::CloseShaderbytecode(const class FString& LibraryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "CloseShaderbytecode");

	Params::FlibPakHelper_CloseShaderbytecode Parms{};

	Parms.LibraryName = std::move(LibraryName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HotPatcherRuntime.FlibPakHelper.CreateFileByBytes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InFile                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<uint8>&                    InBytes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InWriteFlag                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPakHelper::CreateFileByBytes(const class FString& InFile, const TArray<uint8>& InBytes, int32 InWriteFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "CreateFileByBytes");

	Params::FlibPakHelper_CreateFileByBytes Parms{};

	Parms.InFile = std::move(InFile);
	Parms.InBytes = std::move(InBytes);
	Parms.InWriteFlag = InWriteFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.ExecMountPak
// (Final, Exec, Native, Static, Public)
// Parameters:
// const class FString&                    InPakPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPakOrder                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InMountPoint                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlibPakHelper::ExecMountPak(const class FString& InPakPath, int32 InPakOrder, const class FString& InMountPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "ExecMountPak");

	Params::FlibPakHelper_ExecMountPak Parms{};

	Parms.InPakPath = std::move(InPakPath);
	Parms.InPakOrder = InPakOrder;
	Parms.InMountPoint = std::move(InMountPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HotPatcherRuntime.FlibPakHelper.GetAllMountedPaks
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FString> UFlibPakHelper::GetAllMountedPaks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "GetAllMountedPaks");

	Params::FlibPakHelper_GetAllMountedPaks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.GetPakOrderByPakPath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    PakFile                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFlibPakHelper::GetPakOrderByPakPath(const class FString& PakFile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "GetPakOrderByPakPath");

	Params::FlibPakHelper_GetPakOrderByPakPath Parms{};

	Parms.PakFile = std::move(PakFile);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.LoadAssetRegistry
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    LibraryName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    LibraryDir                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPakHelper::LoadAssetRegistry(const class FString& LibraryName, const class FString& LibraryDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "LoadAssetRegistry");

	Params::FlibPakHelper_LoadAssetRegistry Parms{};

	Parms.LibraryName = std::move(LibraryName);
	Parms.LibraryDir = std::move(LibraryDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.LoadShaderbytecode
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    LibraryName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    LibraryDir                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPakHelper::LoadShaderbytecode(const class FString& LibraryName, const class FString& LibraryDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "LoadShaderbytecode");

	Params::FlibPakHelper_LoadShaderbytecode Parms{};

	Parms.LibraryName = std::move(LibraryName);
	Parms.LibraryDir = std::move(LibraryDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.LoadShaderbytecodeInDefaultDir
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    LibraryName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPakHelper::LoadShaderbytecodeInDefaultDir(const class FString& LibraryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "LoadShaderbytecodeInDefaultDir");

	Params::FlibPakHelper_LoadShaderbytecodeInDefaultDir Parms{};

	Parms.LibraryName = std::move(LibraryName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.MountPak
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    PakPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PakOrder                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InMountPoint                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPakHelper::MountPak(const class FString& PakPath, int32 PakOrder, const class FString& InMountPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "MountPak");

	Params::FlibPakHelper_MountPak Parms{};

	Parms.PakPath = std::move(PakPath);
	Parms.PakOrder = PakOrder;
	Parms.InMountPoint = std::move(InMountPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.OpenPSO
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPakHelper::OpenPSO(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "OpenPSO");

	Params::FlibPakHelper_OpenPSO Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.ReloadShaderbytecode
// (Final, Exec, Native, Static, Public, BlueprintCallable)

void UFlibPakHelper::ReloadShaderbytecode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "ReloadShaderbytecode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HotPatcherRuntime.FlibPakHelper.ScanAllVersionDescribleFiles
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FString> UFlibPakHelper::ScanAllVersionDescribleFiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "ScanAllVersionDescribleFiles");

	Params::FlibPakHelper_ScanAllVersionDescribleFiles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.ScanExtenFilesInDirectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InRelativePath                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InExtenPostfix                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InRecursively                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>*                  OutFiles                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPakHelper::ScanExtenFilesInDirectory(const class FString& InRelativePath, const class FString& InExtenPostfix, bool InRecursively, TArray<class FString>* OutFiles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "ScanExtenFilesInDirectory");

	Params::FlibPakHelper_ScanExtenFilesInDirectory Parms{};

	Parms.InRelativePath = std::move(InRelativePath);
	Parms.InExtenPostfix = std::move(InExtenPostfix);
	Parms.InRecursively = InRecursively;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFiles != nullptr)
		*OutFiles = std::move(Parms.OutFiles);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.ScanExtenPakFiles
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FString> UFlibPakHelper::ScanExtenPakFiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "ScanExtenPakFiles");

	Params::FlibPakHelper_ScanExtenPakFiles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.ScanPlatformDirectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InRelativePath                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeFile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeDir                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecursively                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>*                  OutResault                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPakHelper::ScanPlatformDirectory(const class FString& InRelativePath, bool bIncludeFile, bool bIncludeDir, bool bRecursively, TArray<class FString>* OutResault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "ScanPlatformDirectory");

	Params::FlibPakHelper_ScanPlatformDirectory Parms{};

	Parms.InRelativePath = std::move(InRelativePath);
	Parms.bIncludeFile = bIncludeFile;
	Parms.bIncludeDir = bIncludeDir;
	Parms.bRecursively = bRecursively;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResault != nullptr)
		*OutResault = std::move(Parms.OutResault);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPakHelper.UnMountPak
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    PakPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPakHelper::UnMountPak(const class FString& PakPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPakHelper", "UnMountPak");

	Params::FlibPakHelper_UnMountPak Parms{};

	Parms.PakPath = std::move(PakPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.CloseShaderbytecode
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    LibraryName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlibPatchParserHelper::CloseShaderbytecode(const class FString& LibraryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "CloseShaderbytecode");

	Params::FlibPatchParserHelper_CloseShaderbytecode Parms{};

	Parms.LibraryName = std::move(LibraryName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.DiffVersionAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAssetDependenciesInfo&    InNewVersion                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAssetDependenciesInfo&    InBaseVersion                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAssetDependenciesInfo*          OutAddAsset                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FAssetDependenciesInfo*          OutModifyAsset                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FAssetDependenciesInfo*          OutDeleteAsset                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPatchParserHelper::DiffVersionAssets(const struct FAssetDependenciesInfo& InNewVersion, const struct FAssetDependenciesInfo& InBaseVersion, struct FAssetDependenciesInfo* OutAddAsset, struct FAssetDependenciesInfo* OutModifyAsset, struct FAssetDependenciesInfo* OutDeleteAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "DiffVersionAssets");

	Params::FlibPatchParserHelper_DiffVersionAssets Parms{};

	Parms.InNewVersion = std::move(InNewVersion);
	Parms.InBaseVersion = std::move(InBaseVersion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAddAsset != nullptr)
		*OutAddAsset = std::move(Parms.OutAddAsset);

	if (OutModifyAsset != nullptr)
		*OutModifyAsset = std::move(Parms.OutModifyAsset);

	if (OutDeleteAsset != nullptr)
		*OutDeleteAsset = std::move(Parms.OutDeleteAsset);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetAllExFilesByPlatform
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// const struct FPlatformExternAssets&     InPlatformConf                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    InGeneratedHash                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHashCalculator                         HashCalculator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlatformExternFiles             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlatformExternFiles UFlibPatchParserHelper::GetAllExFilesByPlatform(const struct FPlatformExternAssets& InPlatformConf, bool InGeneratedHash, EHashCalculator HashCalculator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetAllExFilesByPlatform");

	Params::FlibPatchParserHelper_GetAllExFilesByPlatform Parms{};

	Parms.InPlatformConf = std::move(InPlatformConf);
	Parms.InGeneratedHash = InGeneratedHash;
	Parms.HashCalculator = HashCalculator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetAvailableMaps
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    GameName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeEngineMaps                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludePluginMaps                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Sorted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FString> UFlibPatchParserHelper::GetAvailableMaps(const class FString& GameName, bool IncludeEngineMaps, bool IncludePluginMaps, bool Sorted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetAvailableMaps");

	Params::FlibPatchParserHelper_GetAvailableMaps Parms{};

	Parms.GameName = std::move(GameName);
	Parms.IncludeEngineMaps = IncludeEngineMaps;
	Parms.IncludePluginMaps = IncludePluginMaps;
	Parms.Sorted = Sorted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetCookedAssetRegistryFiles
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InProjectAbsDir                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InProjectName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InPlatformName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutFiles                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPatchParserHelper::GetCookedAssetRegistryFiles(const class FString& InProjectAbsDir, const class FString& InProjectName, const class FString& InPlatformName, class FString* OutFiles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetCookedAssetRegistryFiles");

	Params::FlibPatchParserHelper_GetCookedAssetRegistryFiles Parms{};

	Parms.InProjectAbsDir = std::move(InProjectAbsDir);
	Parms.InProjectName = std::move(InProjectName);
	Parms.InPlatformName = std::move(InPlatformName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFiles != nullptr)
		*OutFiles = std::move(Parms.OutFiles);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetCookedGlobalShaderCacheFiles
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InProjectDir                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InPlatformName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FString> UFlibPatchParserHelper::GetCookedGlobalShaderCacheFiles(const class FString& InProjectDir, const class FString& InPlatformName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetCookedGlobalShaderCacheFiles");

	Params::FlibPatchParserHelper_GetCookedGlobalShaderCacheFiles Parms{};

	Parms.InProjectDir = std::move(InProjectDir);
	Parms.InPlatformName = std::move(InPlatformName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetCookedShaderBytecodeFiles
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InProjectAbsDir                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InProjectName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InPlatformName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InGalobalBytecode                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InProjectBytecode                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>*                  OutFiles                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPatchParserHelper::GetCookedShaderBytecodeFiles(const class FString& InProjectAbsDir, const class FString& InProjectName, const class FString& InPlatformName, bool InGalobalBytecode, bool InProjectBytecode, TArray<class FString>* OutFiles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetCookedShaderBytecodeFiles");

	Params::FlibPatchParserHelper_GetCookedShaderBytecodeFiles Parms{};

	Parms.InProjectAbsDir = std::move(InProjectAbsDir);
	Parms.InProjectName = std::move(InProjectName);
	Parms.InPlatformName = std::move(InPlatformName);
	Parms.InGalobalBytecode = InGalobalBytecode;
	Parms.InProjectBytecode = InProjectBytecode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFiles != nullptr)
		*OutFiles = std::move(Parms.OutFiles);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetEnabledPluginConfigs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InPlatformName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FString> UFlibPatchParserHelper::GetEnabledPluginConfigs(const class FString& InPlatformName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetEnabledPluginConfigs");

	Params::FlibPatchParserHelper_GetEnabledPluginConfigs Parms{};

	Parms.InPlatformName = std::move(InPlatformName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetEngineConfigs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InPlatformName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FString> UFlibPatchParserHelper::GetEngineConfigs(const class FString& InPlatformName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetEngineConfigs");

	Params::FlibPatchParserHelper_GetEngineConfigs Parms{};

	Parms.InPlatformName = std::move(InPlatformName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetIniConfigs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InSearchDir                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InPlatformName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FString> UFlibPatchParserHelper::GetIniConfigs(const class FString& InSearchDir, const class FString& InPlatformName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetIniConfigs");

	Params::FlibPatchParserHelper_GetIniConfigs Parms{};

	Parms.InSearchDir = std::move(InSearchDir);
	Parms.InPlatformName = std::move(InPlatformName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetPakFileInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    InFile                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPakFileInfo*                    OutFileInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPatchParserHelper::GetPakFileInfo(const class FString& InFile, struct FPakFileInfo* OutFileInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetPakFileInfo");

	Params::FlibPatchParserHelper_GetPakFileInfo Parms{};

	Parms.InFile = std::move(InFile);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFileInfo != nullptr)
		*OutFileInfo = std::move(Parms.OutFileInfo);

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetProjectFilePath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlibPatchParserHelper::GetProjectFilePath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetProjectFilePath");

	Params::FlibPatchParserHelper_GetProjectFilePath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetProjectIniFiles
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InProjectDir                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InPlatformName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FString> UFlibPatchParserHelper::GetProjectIniFiles(const class FString& InProjectDir, const class FString& InPlatformName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetProjectIniFiles");

	Params::FlibPatchParserHelper_GetProjectIniFiles Parms{};

	Parms.InProjectDir = std::move(InProjectDir);
	Parms.InPlatformName = std::move(InPlatformName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.GetProjectName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlibPatchParserHelper::GetProjectName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "GetProjectName");

	Params::FlibPatchParserHelper_GetProjectName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.HashStringWithSHA1
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlibPatchParserHelper::HashStringWithSHA1(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "HashStringWithSHA1");

	Params::FlibPatchParserHelper_HashStringWithSHA1 Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.LoadShaderbytecode
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    LibraryName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    LibraryDir                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibPatchParserHelper::LoadShaderbytecode(const class FString& LibraryName, const class FString& LibraryDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "LoadShaderbytecode");

	Params::FlibPatchParserHelper_LoadShaderbytecode Parms{};

	Parms.LibraryName = std::move(LibraryName);
	Parms.LibraryDir = std::move(LibraryDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibPatchParserHelper.ReloadShaderbytecode
// (Final, Native, Static, Public, BlueprintCallable)

void UFlibPatchParserHelper::ReloadShaderbytecode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibPatchParserHelper", "ReloadShaderbytecode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HotPatcherRuntime.FlibShaderPipelineCacheHelper.EnableLogPSO
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibShaderPipelineCacheHelper::EnableLogPSO(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibShaderPipelineCacheHelper", "EnableLogPSO");

	Params::FlibShaderPipelineCacheHelper_EnableLogPSO Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibShaderPipelineCacheHelper.EnableSaveBoundPSOLog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibShaderPipelineCacheHelper::EnableSaveBoundPSOLog(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibShaderPipelineCacheHelper", "EnableSaveBoundPSOLog");

	Params::FlibShaderPipelineCacheHelper_EnableSaveBoundPSOLog Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibShaderPipelineCacheHelper.EnableShaderPipelineCache
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibShaderPipelineCacheHelper::EnableShaderPipelineCache(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibShaderPipelineCacheHelper", "EnableShaderPipelineCache");

	Params::FlibShaderPipelineCacheHelper_EnableShaderPipelineCache Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibShaderPipelineCacheHelper.IsEnabledLogPSO
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibShaderPipelineCacheHelper::IsEnabledLogPSO()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibShaderPipelineCacheHelper", "IsEnabledLogPSO");

	Params::FlibShaderPipelineCacheHelper_IsEnabledLogPSO Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibShaderPipelineCacheHelper.IsEnabledSaveBoundPSOLog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibShaderPipelineCacheHelper::IsEnabledSaveBoundPSOLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibShaderPipelineCacheHelper", "IsEnabledSaveBoundPSOLog");

	Params::FlibShaderPipelineCacheHelper_IsEnabledSaveBoundPSOLog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibShaderPipelineCacheHelper.IsEnabledUsePSO
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibShaderPipelineCacheHelper::IsEnabledUsePSO()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibShaderPipelineCacheHelper", "IsEnabledUsePSO");

	Params::FlibShaderPipelineCacheHelper_IsEnabledUsePSO Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibShaderPipelineCacheHelper.LoadShaderPipelineCache
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibShaderPipelineCacheHelper::LoadShaderPipelineCache(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibShaderPipelineCacheHelper", "LoadShaderPipelineCache");

	Params::FlibShaderPipelineCacheHelper_LoadShaderPipelineCache Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.FlibShaderPipelineCacheHelper.SavePipelineFileCache
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EPSOSaveMode                            Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlibShaderPipelineCacheHelper::SavePipelineFileCache(EPSOSaveMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlibShaderPipelineCacheHelper", "SavePipelineFileCache");

	Params::FlibShaderPipelineCacheHelper_SavePipelineFileCache Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HotPatcherRuntime.MountListener.Init
// (Final, Native, Public, BlueprintCallable)

void UMountListener::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MountListener", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

