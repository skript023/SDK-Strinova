#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RuntimeMeshComponent

#include "Basic.hpp"

#include "RuntimeMeshComponent_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class RuntimeMeshComponent.RuntimeBlueprintMeshAccessor
// 0x0010 (0x0038 - 0x0028)
class URuntimeBlueprintMeshAccessor : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("RuntimeBlueprintMeshAccessor")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"RuntimeBlueprintMeshAccessor")
	}
	static class URuntimeBlueprintMeshAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<URuntimeBlueprintMeshAccessor>();
	}
};
DUMPER7_ASSERTS_URuntimeBlueprintMeshAccessor;

// Class RuntimeMeshComponent.RuntimeBlueprintMeshBuilder
// 0x0010 (0x0048 - 0x0038)
class URuntimeBlueprintMeshBuilder final : public URuntimeBlueprintMeshAccessor
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddIndex(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 NewIndex);
	int32 AddTriangle(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index0, int32 Index1, int32 Index2);
	int32 AddVertex(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, const struct FVector& InPosition, const struct FVector& Normal, const struct FRuntimeMeshTangent& Tangent, const struct FVector2D& UV0, const struct FLinearColor& Color);
	void EmptyIndices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Slack);
	void EmptyVertices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Slack);
	struct FLinearColor GetColor(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0);
	int32 GetIndex(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0);
	struct FVector4 GetNormal(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0);
	struct FVector GetPosition(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0);
	struct FVector GetTangent(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0);
	struct FVector2D GetUV(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, int32 Channel);
	bool IsReadonly(class URuntimeBlueprintMeshBuilder** OutMeshBuilder);
	bool IsUsing32BitIndices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder);
	bool IsUsingHighPrecisionTangents(class URuntimeBlueprintMeshBuilder** OutMeshBuilder);
	bool IsUsingHighPrecisionUVs(class URuntimeBlueprintMeshBuilder** OutMeshBuilder);
	int32 NumIndices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder);
	int32 NumUVChannels(class URuntimeBlueprintMeshBuilder** OutMeshBuilder);
	int32 NumVertices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder);
	int32 SetColor(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FLinearColor& Value);
	void SetIndex(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, int32 Value);
	int32 SetNormal(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector4& Value);
	int32 SetNormalTangent(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector& Normal, const struct FRuntimeMeshTangent& Tangent);
	void SetNumIndices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 NewNum);
	void SetNumVertices(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 NewNum);
	int32 SetPosition(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector& Value);
	int32 SetTangent(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FRuntimeMeshTangent& Value);
	int32 SetTangents(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector& TangentX, const struct FVector& TangentY, const struct FVector& TangentZ);
	int32 SetUV(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector2D& Value, int32 Channel);
	int32 SetVertex(class URuntimeBlueprintMeshBuilder** OutMeshBuilder, int32 Index_0, const struct FVector& InPosition, const struct FVector& Normal, const struct FRuntimeMeshTangent& Tangent, const struct FVector2D& UV0, const struct FLinearColor& Color);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("RuntimeBlueprintMeshBuilder")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"RuntimeBlueprintMeshBuilder")
	}
	static class URuntimeBlueprintMeshBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URuntimeBlueprintMeshBuilder>();
	}
};
DUMPER7_ASSERTS_URuntimeBlueprintMeshBuilder;

// Class RuntimeMeshComponent.RuntimeMesh
// 0x0078 (0x00A0 - 0x0028)
class URuntimeMesh final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseComplexAsSimpleCollision;                      // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseAsyncCooking;                                  // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldSerializeMeshData;                          // 0x0072(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERuntimeMeshCollisionCookingMode              CollisionMode;                                     // 0x0073(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBodySetup*>                     AsyncBodySetupQueue;                               // 0x0080(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              CollisionUpdated;                                  // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 AddCollisionBox(const struct FRuntimeMeshCollisionBox& NewBox);
	int32 AddCollisionCapsule(const struct FRuntimeMeshCollisionCapsule& NewCapsule);
	int32 AddCollisionSphere(const struct FRuntimeMeshCollisionSphere& NewSphere);
	int32 AddConvexCollisionSection(const TArray<struct FVector>& ConvexVerts);
	void ClearAllConvexCollisionSections();
	void ClearAllMeshCollisionSections();
	void ClearAllMeshSections();
	void ClearCollisionBoxes();
	void ClearCollisionCapsules();
	void ClearCollisionSpheres();
	void ClearConvexCollisionSection(int32 ConvexSectionIndex);
	void ClearMeshCollisionSection(int32 CollisionSectionIndex);
	void ClearMeshSection(int32 SectionIndex);
	void CookCollisionNow();
	void CreateMeshSection_Blueprint(int32 SectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, const TArray<struct FVector>& Normals, const TArray<struct FRuntimeMeshTangent>& Tangents, const TArray<struct FVector2D>& UV0, const TArray<struct FVector2D>& UV1, const TArray<struct FLinearColor>& Colors, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs);
	void CreateMeshSectionFromBuilder(int32 SectionID, class URuntimeBlueprintMeshBuilder* MeshData, bool bCreateCollision, EUpdateFrequency UpdateFrequency);
	void CreateMeshSectionPacked_Blueprint(int32 SectionIndex, const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs);
	struct FBox GetSectionBoundingBox(int32 SectionIndex);
	class UMaterialInterface* GetSectionMaterial(int32 SectionID);
	bool IsCollisionUsingAsyncCooking();
	bool IsCollisionUsingComplexAsSimple();
	bool IsMeshSectionCollisionEnabled(int32 SectionIndex);
	void RemoveCollisionBox(int32 Index_0);
	void RemoveCollisionCapsule(int32 Index_0);
	void RemoveCollisionSphere(int32 Index_0);
	void SetCollisionBoxes(const TArray<struct FRuntimeMeshCollisionBox>& NewBoxes);
	void SetCollisionCapsules(const TArray<struct FRuntimeMeshCollisionCapsule>& NewCapsules);
	void SetCollisionMode(ERuntimeMeshCollisionCookingMode NewMode);
	void SetCollisionSpheres(const TArray<struct FRuntimeMeshCollisionSphere>& NewSpheres);
	void SetCollisionUseAsyncCooking(bool bNewValue);
	void SetCollisionUseComplexAsSimple(bool bNewValue);
	void SetConvexCollisionSection(int32 ConvexSectionIndex, const TArray<struct FVector>& ConvexVerts);
	void SetMeshCollisionSection(int32 CollisionSectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles);
	void SetMeshSectionCastsShadow(int32 SectionIndex, bool bNewCastsShadow);
	void SetMeshSectionCollisionEnabled(int32 SectionIndex, bool bNewCollisionEnabled);
	void SetMeshSectionVisible(int32 SectionIndex, bool bNewVisibility);
	void SetSectionMaterial(int32 SectionID, class UMaterialInterface* Material);
	void SetSectionTessellationTriangles(int32 SectionID, const TArray<int32>& Triangles);
	void SetShouldSerializeMeshData(bool bShouldSerialize);
	bool ShouldSerializeMeshData();
	void UpdateMeshSection_Blueprint(int32 SectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, const TArray<struct FVector>& Normals, const TArray<struct FRuntimeMeshTangent>& Tangents, const TArray<struct FVector2D>& UV0, const TArray<struct FVector2D>& UV1, const TArray<struct FLinearColor>& Colors, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles);
	void UpdateMeshSectionFromBuilder(int32 SectionID, class URuntimeBlueprintMeshBuilder* MeshData);
	void UpdateMeshSectionPacked_Blueprint(int32 SectionIndex, const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles);

	bool DoesSectionExist(int32 SectionIndex) const;
	int32 GetAvailableSectionIndex() const;
	ERuntimeMeshCollisionCookingMode GetCollisionMode() const;
	class UMaterialInterface* GetMaterialFromCollisionFaceIndex(int32 FaceIndex, int32* SectionIndex) const;
	int32 GetNumSections() const;
	void GetSectionIdAndFaceIdFromCollisionFaceIndex(int32 FaceIndex, int32* SectionIndex, int32* SectionFaceIndex) const;
	int32 GetSectionIdFromCollisionFaceIndex(int32 FaceIndex) const;
	bool IsMeshSectionCastingShadows(int32 SectionIndex) const;
	bool IsMeshSectionVisible(int32 SectionIndex) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("RuntimeMesh")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"RuntimeMesh")
	}
	static class URuntimeMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<URuntimeMesh>();
	}
};
DUMPER7_ASSERTS_URuntimeMesh;

// Class RuntimeMeshComponent.RuntimeMeshActor
// 0x0010 (0x02E0 - 0x02D0)
class ARuntimeMeshActor final : public AActor
{
public:
	class URuntimeMeshComponent*                  RuntimeMeshComponent;                              // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRunGenerateMeshesOnConstruction;                  // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunGenerateMeshesOnBeginPlay;                     // 0x02D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA[0x6];                                      // 0x02DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateMeshes();
	ERuntimeMeshMobility GetRuntimeMeshMobility();
	void SetRuntimeMeshMobility(ERuntimeMeshMobility NewMobility);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("RuntimeMeshActor")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"RuntimeMeshActor")
	}
	static class ARuntimeMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARuntimeMeshActor>();
	}
};
DUMPER7_ASSERTS_ARuntimeMeshActor;

// Class RuntimeMeshComponent.RuntimeMeshBuilderFunctions
// 0x0000 (0x0028 - 0x0028)
class URuntimeMeshBuilderFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class URuntimeBlueprintMeshBuilder* MakeRuntimeMeshBuilder(bool bWantsHighPrecisionTangents, bool bWantsHighPrecisionUVs, int32 NumUVs, bool bUse16BitIndices);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("RuntimeMeshBuilderFunctions")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"RuntimeMeshBuilderFunctions")
	}
	static class URuntimeMeshBuilderFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<URuntimeMeshBuilderFunctions>();
	}
};
DUMPER7_ASSERTS_URuntimeMeshBuilderFunctions;

// Class RuntimeMeshComponent.RuntimeMeshComponent
// 0x0040 (0x0500 - 0x04C0)
class URuntimeMeshComponent : public UMeshComponent
{
public:
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URuntimeMesh*                           RuntimeMeshReference;                              // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               OS_MID;                                            // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBodySetup*                             BodySetup;                                         // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBodySetup*>                     AsyncBodySetupQueue;                               // 0x04E8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddCollisionBox(const struct FRuntimeMeshCollisionBox& NewBox);
	int32 AddCollisionCapsule(const struct FRuntimeMeshCollisionCapsule& NewCapsule);
	int32 AddCollisionSphere(const struct FRuntimeMeshCollisionSphere& NewSphere);
	int32 AddConvexCollisionSection(const TArray<struct FVector>& ConvexVerts);
	void ClearAllConvexCollisionSections();
	void ClearAllMeshCollisionSections();
	void ClearAllMeshSections();
	void ClearCollisionBoxes();
	void ClearCollisionCapsules();
	void ClearCollisionSpheres();
	void ClearConvexCollisionSection(int32 ConvexSectionIndex);
	void ClearMeshCollisionSection(int32 CollisionSectionIndex);
	void ClearMeshSection(int32 SectionIndex);
	void CookCollisionNow();
	void CreateMeshSection_Blueprint(int32 SectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, const TArray<struct FVector>& Normals, const TArray<struct FRuntimeMeshTangent>& Tangents, const TArray<struct FVector2D>& UV0, const TArray<struct FVector2D>& UV1, const TArray<struct FLinearColor>& Colors, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs);
	void CreateMeshSectionFromBuilder(int32 SectionID, class URuntimeBlueprintMeshBuilder* MeshData, bool bCreateCollision, EUpdateFrequency UpdateFrequency);
	void CreateMeshSectionPacked_Blueprint(int32 SectionIndex, const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs);
	class URuntimeMesh* GetOrCreateRuntimeMesh();
	ERuntimeMeshMobility GetRuntimeMeshMobility();
	struct FBox GetSectionBoundingBox(int32 SectionIndex);
	class UMaterialInterface* GetSectionMaterial(int32 SectionID);
	bool IsCollisionUsingAsyncCooking();
	bool IsCollisionUsingComplexAsSimple();
	bool IsMeshSectionCollisionEnabled(int32 SectionIndex);
	void RemoveCollisionBox(int32 Index_0);
	void RemoveCollisionCapsule(int32 Index_0);
	void RemoveCollisionSphere(int32 Index_0);
	void SetCollisionBoxes(const TArray<struct FRuntimeMeshCollisionBox>& NewBoxes);
	void SetCollisionCapsules(const TArray<struct FRuntimeMeshCollisionCapsule>& NewCapsules);
	void SetCollisionMode(ERuntimeMeshCollisionCookingMode NewMode);
	void SetCollisionSpheres(const TArray<struct FRuntimeMeshCollisionSphere>& NewSpheres);
	void SetCollisionUseAsyncCooking(bool bNewValue);
	void SetCollisionUseComplexAsSimple(bool bNewValue);
	void SetConvexCollisionSection(int32 ConvexSectionIndex, const TArray<struct FVector>& ConvexVerts);
	void SetMeshCollisionSection(int32 CollisionSectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles);
	ERuntimeMeshSetAction SetMeshSection_Blueprint(int32 SectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, const TArray<struct FVector>& Normals, const TArray<struct FRuntimeMeshTangent>& Tangents, const TArray<struct FVector2D>& UV0, const TArray<struct FVector2D>& UV1, const TArray<struct FLinearColor>& Colors, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs);
	void SetMeshSectionCastsShadow(int32 SectionIndex, bool bNewCastsShadow);
	void SetMeshSectionCollisionEnabled(int32 SectionIndex, bool bNewCollisionEnabled);
	ERuntimeMeshSetAction SetMeshSectionPacked_Blueprint(int32 SectionIndex, const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles, bool bCreateCollision, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles, EUpdateFrequency UpdateFrequency, bool bUseHighPrecisionTangents, bool bUseHighPrecisionUVs);
	void SetMeshSectionVisible(int32 SectionIndex, bool bNewVisibility);
	void SetRuntimeMesh(class URuntimeMesh* NewMesh);
	void SetRuntimeMeshMobility(ERuntimeMeshMobility NewMobility);
	void SetSectionMaterial(int32 SectionID, class UMaterialInterface* Material);
	void SetShouldSerializeMeshData(bool bShouldSerialize);
	bool ShouldSerializeMeshData();
	void UpdateMeshSection_Blueprint(int32 SectionIndex, const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, const TArray<struct FVector>& Normals, const TArray<struct FRuntimeMeshTangent>& Tangents, const TArray<struct FVector2D>& UV0, const TArray<struct FVector2D>& UV1, const TArray<struct FLinearColor>& Colors, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles);
	void UpdateMeshSectionFromBuilder(int32 SectionID, class URuntimeBlueprintMeshBuilder* MeshData);
	void UpdateMeshSectionPacked_Blueprint(int32 SectionIndex, const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles, bool bCalculateNormalTangent, bool bShouldCreateHardTangents, bool bGenerateTessellationTriangles);

	bool DoesSectionExist(int32 SectionIndex) const;
	int32 GetAvailableSectionIndex() const;
	int32 GetNumSections() const;
	class URuntimeMesh* GetRuntimeMesh() const;
	void GetSectionIdAndFaceIdFromCollisionFaceIndex(int32 FaceIndex, int32* SectionIndex, int32* SectionFaceIndex) const;
	int32 GetSectionIdFromCollisionFaceIndex(int32 FaceIndex) const;
	bool IsAsyncCollisionCookingPending() const;
	bool IsMeshSectionCastingShadows(int32 SectionIndex) const;
	bool IsMeshSectionVisible(int32 SectionIndex) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("RuntimeMeshComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"RuntimeMeshComponent")
	}
	static class URuntimeMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URuntimeMeshComponent>();
	}
};
DUMPER7_ASSERTS_URuntimeMeshComponent;

// Class RuntimeMeshComponent.RuntimeMeshLibrary
// 0x0000 (0x0028 - 0x0028)
class URuntimeMeshLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CalculateTangentsForMesh(const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, TArray<struct FVector>* Normals, const TArray<struct FVector2D>& UVs, TArray<struct FRuntimeMeshTangent>* Tangents, bool bCreateSmoothNormals);
	static void CalculateTangentsForMeshPacked(TArray<struct FRuntimeMeshBlueprintVertexSimple>* Vertices, const TArray<int32>& Triangles, bool bCreateSmoothNormals);
	static void CopyCollisionFromStaticMesh(class UStaticMesh* StaticMesh, class URuntimeMesh* RuntimeMesh);
	static void CopyStaticMeshToRuntimeMesh(class UStaticMeshComponent* StaticMeshComponent, int32 LODIndex, class URuntimeMesh* RuntimeMesh, bool bCreateCollision);
	static void CopyStaticMeshToRuntimeMeshComponent(class UStaticMeshComponent* StaticMeshComponent, int32 LODIndex, class URuntimeMeshComponent* RuntimeMeshComponent, bool bCreateCollision);
	static void CopyStaticMeshToRuntimeMeshComponentWithoutCollision(class UStaticMeshComponent* StaticMeshComponent, int32 LODIndex, class UMaterialInterface* MaterialInterface, class URuntimeMeshComponent* RuntimeMeshComponent);
	static TArray<int32> GenerateTessellationIndexBuffer(const TArray<struct FVector>& Vertices, const TArray<int32>& Triangles, TArray<struct FVector>* Normals, const TArray<struct FVector2D>& UVs, TArray<struct FRuntimeMeshTangent>* Tangents);
	static TArray<int32> GenerateTessellationIndexBufferPacked(const TArray<struct FRuntimeMeshBlueprintVertexSimple>& Vertices, const TArray<int32>& Triangles);
	static void GetStaticMeshSection(class UStaticMesh* InMesh, int32 LODIndex, int32 SectionIndex, TArray<struct FVector>* Vertices, TArray<int32>* Triangles, TArray<struct FVector>* Normals, TArray<struct FVector2D>* UVs, TArray<struct FColor>* Colors, TArray<struct FRuntimeMeshTangent>* Tangents);
	static void GetStaticMeshSectionPacked(class UStaticMesh* InMesh, int32 LODIndex, int32 SectionIndex, TArray<struct FRuntimeMeshBlueprintVertexSimple>* Vertices, TArray<int32>* Triangles);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("RuntimeMeshLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"RuntimeMeshLibrary")
	}
	static class URuntimeMeshLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URuntimeMeshLibrary>();
	}
};
DUMPER7_ASSERTS_URuntimeMeshLibrary;

// Class RuntimeMeshComponent.RuntimeMeshShapeGenerator
// 0x0000 (0x0028 - 0x0028)
class URuntimeMeshShapeGenerator final : public UBlueprintFunctionLibrary
{
public:
	static void ConvertQuadToTriangles(TArray<int32>& Triangles, int32 Vert0, int32 Vert1, int32 Vert2, int32 Vert3);
	static void CreateBoxMesh(const struct FVector& BoxRadius, TArray<struct FVector>* Vertices, TArray<int32>* Triangles, TArray<struct FVector>* Normals, TArray<struct FVector2D>* UVs, TArray<struct FRuntimeMeshTangent>* Tangents);
	static void CreateBoxMeshPacked(const struct FVector& BoxRadius, TArray<struct FRuntimeMeshBlueprintVertexSimple>* Vertices, TArray<int32>* Triangles);
	static void CreateGridMesh(float Width, float Height, int32 NumSubdivisionsX, int32 NumSubdivisionsY, TArray<struct FVector>* Vertices, TArray<int32>* Triangles, TArray<struct FVector>* Normals, TArray<struct FVector2D>* UVs, TArray<struct FRuntimeMeshTangent>* Tangents);
	static void CreateGridMeshPacked(float Width, float Height, int32 NumSubdivisionsX, int32 NumSubdivisionsY, TArray<struct FRuntimeMeshBlueprintVertexSimple>* Vertices, TArray<int32>* Triangles);
	static void CreateGridMeshTriangles(int32 NumX, int32 NumY, bool bWinding, TArray<int32>* Triangles);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("RuntimeMeshShapeGenerator")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"RuntimeMeshShapeGenerator")
	}
	static class URuntimeMeshShapeGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URuntimeMeshShapeGenerator>();
	}
};
DUMPER7_ASSERTS_URuntimeMeshShapeGenerator;

// Class RuntimeMeshComponent.RuntimeMeshSlicer
// 0x0000 (0x0028 - 0x0028)
class URuntimeMeshSlicer final : public UBlueprintFunctionLibrary
{
public:
	static void SliceRuntimeMesh(class URuntimeMesh* InRuntimeMesh, const struct FVector& PlanePosition, const struct FVector& PlaneNormal, class URuntimeMesh* OutOtherHalf, ERuntimeMeshSlicerCapOption CapOption, class UMaterialInterface* CapMaterial);
	static void SliceRuntimeMeshComponent(class URuntimeMeshComponent* InRuntimeMesh, const struct FVector& PlanePosition, const struct FVector& PlaneNormal, bool bCreateOtherHalf, class URuntimeMeshComponent** OutOtherHalf, ERuntimeMeshSlicerCapOption CapOption, class UMaterialInterface* CapMaterial);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("RuntimeMeshSlicer")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"RuntimeMeshSlicer")
	}
	static class URuntimeMeshSlicer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URuntimeMeshSlicer>();
	}
};
DUMPER7_ASSERTS_URuntimeMeshSlicer;

}

